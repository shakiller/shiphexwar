<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ì–µ–∫—Å–∞–≥–æ–Ω–∞–ª—å–Ω—ã–π –ú–æ—Ä—Å–∫–æ–π –ë–æ–π</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: white;
        }

        .container {
            max-width: 1200px;
            width: 100%;
            text-align: center;
        }

        h1 {
            color: white;
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .game-info {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }

        .players {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
        }

        .player {
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.2em;
            font-weight: bold;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.1);
            position: relative;
            border: 2px solid transparent;
        }

        .player.active {
            background: rgba(76, 175, 80, 0.3);
            border: 2px solid #4CAF50;
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }

        .player.me { border-left: 4px solid #4CAF50; }
        .player.opponent { border-left: 4px solid #FF5252; }

        .score {
            font-size: 1.5em;
            color: #fff;
            margin-top: 5px;
        }

        .controls {
            margin: 20px 0;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 25px;
            border: none;
            border-radius: 5px;
            font-size: 1em;
            background: #4CAF50;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        button:hover {
            background: #45a049;
            transform: translateY(-2px);
        }

        .rotation-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        .rotation-btn {
            background: #2196F3;
            padding: 8px 15px;
            font-size: 0.9em;
        }

        .rotation-info {
            font-size: 0.9em;
            color: #FFD700;
            font-weight: bold;
        }

        .game-boards {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .board-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            position: relative;
        }

        .board-title {
            margin-bottom: 10px;
            font-size: 1.2em;
            font-weight: bold;
        }

        canvas {
            display: block;
            margin: 0 auto;
            cursor: pointer;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(0, 0, 50, 0.7);
            border-radius: 10px;
        }

        .ship-palette {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 12px;
            flex-wrap: wrap;
        }

        .ship {
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
        }

        .ship.selected {
            background: rgba(76, 175, 80, 0.5);
            border: 2px solid #4CAF50;
        }

        .ship.placed {
            background: rgba(100, 100, 100, 0.5);
            cursor: not-allowed;
        }

        .online-buttons {
            text-align: center;
            margin: 15px 0;
        }

        .online-buttons input {
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 0.9em;
            margin: 5px;
            background: rgba(255, 255, 255, 0.9);
        }

        #connectionStatus {
            transition: all 0.3s ease;
            padding: 8px;
            border-radius: 5px;
            margin-top: 8px;
            display: none;
            font-size: 0.9em;
        }

        #roomInfo {
            background: rgba(233, 236, 239, 0.2);
            padding: 8px;
            border-radius: 5px;
            border-left: 4px solid #4CAF50;
            margin-top: 8px;
            display: none;
            font-size: 0.9em;
        }

        .game-phase {
            font-size: 1.1em;
            margin: 12px 0;
            font-weight: bold;
            color: #FFD700;
        }

        .instructions {
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            border-radius: 10px;
            margin-top: 15px;
            font-size: 0.85em;
            color: #ccc;
            backdrop-filter: blur(10px);
        }

        .delete-hint {
            color: #FF5252;
            font-size: 0.8em;
            margin-top: 5px;
        }

        .debug-info {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px;
            border-radius: 5px;
            margin-top: 10px;
            font-size: 0.8em;
            color: #ccc;
            display: none;
        }

        .mouse-coords {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px;
            border-radius: 3px;
            font-size: 0.7em;
            color: white;
        }

        /* –ú–µ–¥–∏–∞-–∑–∞–ø—Ä–æ—Å—ã –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤ */
        @media (max-width: 768px) {
            .game-boards {
                flex-direction: column;
                align-items: center;
            }
            
            .board-container {
                margin-bottom: 15px;
            }
            
            canvas {
                width: 350px !important;
                height: 350px !important;
            }
            
            .players {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚öì –ì–µ–∫—Å–∞–≥–æ–Ω–∞–ª—å–Ω—ã–π –ú–æ—Ä—Å–∫–æ–π –ë–æ–π</h1>
        
        <div class="game-info">
            <div class="game-mode">
                <button class="mode-btn active" id="modeLocal">üë• –õ–æ–∫–∞–ª—å–Ω–∞—è –∏–≥—Ä–∞</button>
                <button class="mode-btn" id="modeOnline">üåê –û–Ω–ª–∞–π–Ω –∏–≥—Ä–∞</button>
            </div>
            
            <div id="onlineLobby" style="display: none;">
                <h3>–û–Ω–ª–∞–π–Ω –∏–≥—Ä–∞</h3>
                <div class="online-buttons">
                    <button onclick="createOnlineGame()" class="control-btn">–°–æ–∑–¥–∞—Ç—å –∫–æ–º–Ω–∞—Ç—É</button>
                    <div style="margin: 8px 0; text-align: center">–∏–ª–∏</div>
                    <input type="text" id="roomIdInput" placeholder="ID –∫–æ–º–Ω–∞—Ç—ã">
                    <button onclick="joinOnlineGame()" class="control-btn">–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è</button>
                </div>
                <div id="connectionStatus"></div>
                <div id="roomInfo"></div>
            </div>
            
            <div class="players">
                <div class="player me" id="playerMe">
                    –í–∞—à —Ñ–ª–æ—Ç
                    <div class="score" id="scoreMe">0 –∫–æ—Ä–∞–±–ª–µ–π</div>
                </div>
                <div class="player opponent" id="playerOpponent">
                    –§–ª–æ—Ç –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞
                    <div class="score" id="scoreOpponent">0 –∫–æ—Ä–∞–±–ª–µ–π</div>
                </div>
            </div>
            
            <div class="game-phase" id="gamePhase">–§–∞–∑–∞ —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∏ –∫–æ—Ä–∞–±–ª–µ–π</div>
            
            <div class="controls">
                <button id="randomShips">–°–ª—É—á–∞–π–Ω–∞—è —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∞</button>
                <button id="startGame" style="display: none;">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
                <button id="newGameBtn">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
            </div>

            <div class="rotation-controls">
                <button class="rotation-btn" id="rotateLeft">‚Ü∂ –ü–æ–≤–µ—Ä–Ω—É—Ç—å –≤–ª–µ–≤–æ</button>
                <div class="rotation-info" id="rotationInfo">–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: ‚Üí</div>
                <button class="rotation-btn" id="rotateRight">–ü–æ–≤–µ—Ä–Ω—É—Ç—å –≤–ø—Ä–∞–≤–æ ‚Ü∑</button>
            </div>
            
            <div class="ship-palette" id="shipPalette">
                <!-- –ö–æ—Ä–∞–±–ª–∏ –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª–µ–Ω—ã –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ -->
            </div>
            <div class="delete-hint">üí° –î–ª—è —É–¥–∞–ª–µ–Ω–∏—è –∫–æ—Ä–∞–±–ª—è –∫–ª–∏–∫–Ω–∏—Ç–µ –ø–æ –Ω–µ–º—É –Ω–∞ –ø–æ–ª–µ</div>
            <div class="debug-info" id="debugInfo"></div>
        </div>

        <div class="game-boards">
            <div class="board-container">
                <div class="board-title">–í–∞—à–µ –ø–æ–ª–µ</div>
                <div class="mouse-coords" id="myBoardCoords">x: 0, y: 0</div>
                <canvas id="myBoard" width="500" height="500"></canvas>
            </div>
            <div class="board-container">
                <div class="board-title">–ü–æ–ª–µ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞</div>
                <div class="mouse-coords" id="opponentBoardCoords">x: 0, y: 0</div>
                <canvas id="opponentBoard" width="500" height="500"></canvas>
            </div>
        </div>

        <div class="instructions">
            <p><strong>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ:</strong> –ö–ª–∏–∫–Ω–∏—Ç–µ –Ω–∞ –∫–æ—Ä–∞–±–ª—å –≤ –ø–∞–ª–∏—Ç—Ä–µ, –∑–∞—Ç–µ–º –Ω–∞ –ø–æ–ª–µ –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –ø–æ–≤–æ—Ä–æ—Ç–∞ –∏–ª–∏ –∫–ª–∞–≤–∏—à—É R.</p>
            <p><strong>–¶–µ–ª—å:</strong> –ü–µ—Ä–≤—ã–º –ø–æ—Ç–æ–ø–∏—Ç–µ –≤—Å–µ –∫–æ—Ä–∞–±–ª–∏ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞!</p>
        </div>
    </div>

    <script>
        class HexagonalBattleship {
            constructor() {
                this.myBoardCanvas = document.getElementById('myBoard');
                this.opponentBoardCanvas = document.getElementById('opponentBoard');
                this.myCtx = this.myBoardCanvas.getContext('2d');
                this.opponentCtx = this.opponentBoardCanvas.getContext('2d');
                
                // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –º—ã—à–∏
                this.currentMouseX = 0;
                this.currentMouseY = 0;
                this.lastHoveredHex = null;
                
                // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–≥—Ä—ã
                this.boardSize = 8;
                this.ships = [
                    { size: 4, count: 1, name: "–õ–∏–Ω–∫–æ—Ä" },
                    { size: 3, count: 2, name: "–ö—Ä–µ–π—Å–µ—Ä" },
                    { size: 2, count: 3, name: "–≠—Å–º–∏–Ω–µ—Ü" },
                    { size: 1, count: 4, name: "–ö–∞—Ç–µ—Ä" }
                ];
                
                // –ò–≥—Ä–æ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
                this.myBoard = [];
                this.opponentBoard = [];
                this.myShips = [];
                this.opponentShips = [];
                this.myShots = [];
                this.opponentShots = [];
                this.currentPlayer = 'me';
                this.gamePhase = 'setup';
                this.selectedShip = null;
                this.shipOrientation = 0;
                
                // –ù–∞–∑–≤–∞–Ω–∏—è –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
                this.directionNames = ['‚Üí', '‚Üó', '‚Üñ', '‚Üê', '‚Üô', '‚Üò'];
                
                // –û–Ω–ª–∞–π–Ω-–ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
                this.peer = null;
                this.connection = null;
                this.isOnline = false;
                this.isHost = false;
                this.roomId = null;
                
                this.initializeGame();
                this.setupEventListeners();
                this.createShipPalette();
                this.drawBoards();
            }
            
            initializeGame() {
                this.myBoard = Array(this.boardSize).fill().map(() => Array(this.boardSize).fill(''));
                this.opponentBoard = Array(this.boardSize).fill().map(() => Array(this.boardSize).fill(''));
                
                this.myShips = [];
                this.opponentShips = [];
                this.myShots = [];
                this.opponentShots = [];
                this.currentPlayer = 'me';
                this.gamePhase = 'setup';
                this.selectedShip = null;
                this.shipOrientation = 0;
                this.lastHoveredHex = null;
                
                this.updateGamePhase();
                this.updateScores();
                this.updateRotationInfo();
                this.drawBoards();
                this.createShipPalette();
                
                document.getElementById('startGame').style.display = this.isOnline ? 'none' : 'block';
            }
            
            setupEventListeners() {
                // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–ª–∏–∫–æ–≤
                this.myBoardCanvas.addEventListener('click', (e) => this.handleMyBoardClick(e));
                this.opponentBoardCanvas.addEventListener('click', (e) => this.handleOpponentBoardClick(e));
                
                // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–≤–∏–∂–µ–Ω–∏—è –º—ã—à–∏ –¥–ª—è –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞
                this.myBoardCanvas.addEventListener('mousemove', (e) => {
                    const rect = this.myBoardCanvas.getBoundingClientRect();
                    this.currentMouseX = e.clientX - rect.left;
                    this.currentMouseY = e.clientY - rect.top;
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –Ω–∞ –¥–∏—Å–ø–ª–µ–µ
                    document.getElementById('myBoardCoords').textContent = 
                        `x: ${Math.floor(this.currentMouseX)}, y: ${Math.floor(this.currentMouseY)}`;
                    
                    this.handleMouseMove(this.currentMouseX, this.currentMouseY, this.myBoardCanvas);
                });
                
                this.opponentBoardCanvas.addEventListener('mousemove', (e) => {
                    const rect = this.opponentBoardCanvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –Ω–∞ –¥–∏—Å–ø–ª–µ–µ
                    document.getElementById('opponentBoardCoords').textContent = 
                        `x: ${Math.floor(x)}, y: ${Math.floor(y)}`;
                });
                
                // –£–±–∏—Ä–∞–µ–º –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –ø—Ä–∏ —É—Ö–æ–¥–µ –º—ã—à–∏ —Å –ø–æ–ª—è
                this.myBoardCanvas.addEventListener('mouseleave', () => {
                    this.lastHoveredHex = null;
                    this.drawBoards();
                });

                // –û—Å—Ç–∞–ª—å–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
                document.getElementById('modeLocal').addEventListener('click', () => this.setGameMode('local'));
                document.getElementById('modeOnline').addEventListener('click', () => this.setGameMode('online'));
                document.getElementById('randomShips').addEventListener('click', () => this.randomizeShips());
                document.getElementById('startGame').addEventListener('click', () => this.startBattle());
                document.getElementById('newGameBtn').addEventListener('click', () => this.initializeGame());
                document.getElementById('rotateLeft').addEventListener('click', () => this.rotateLeft());
                document.getElementById('rotateRight').addEventListener('click', () => this.rotateRight());
                
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'r' || e.key === '–∫' || e.key === 'R' || e.key === '–ô') {
                        this.rotateRight();
                    }
                    if (e.key === 'q' || e.key === '–π' || e.key === 'Q' || e.key === '–ô') {
                        this.rotateLeft();
                    }
                });

                window.addEventListener('resize', () => {
                    this.drawBoards();
                });
            }
            
            handleMouseMove(x, y, canvas) {
                if (this.gamePhase !== 'setup' || !this.selectedShip) return;
                
                const hex = this.getHexAtPosition(x, y, canvas);
                if (hex && (this.lastHoveredHex === null || hex.row !== this.lastHoveredHex.row || hex.col !== this.lastHoveredHex.col)) {
                    this.lastHoveredHex = hex;
                    this.drawBoards();
                }
            }
            
            rotateLeft() {
                this.shipOrientation = (this.shipOrientation + 5) % 6;
                this.updateRotationInfo();
                this.drawBoards();
            }
            
            rotateRight() {
                this.shipOrientation = (this.shipOrientation + 1) % 6;
                this.updateRotationInfo();
                this.drawBoards();
            }
            
            updateRotationInfo() {
                const rotationInfo = document.getElementById('rotationInfo');
                rotationInfo.textContent = `–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: ${this.directionNames[this.shipOrientation]}`;
            }
            
            setGameMode(mode) {
                this.isOnline = mode === 'online';
                document.getElementById('onlineLobby').style.display = this.isOnline ? 'block' : 'none';
                
                document.getElementById('modeLocal').classList.toggle('active', mode === 'local');
                document.getElementById('modeOnline').classList.toggle('active', mode === 'online');
                
                if (mode === 'local') {
                    this.leaveOnlineGame();
                }
            }
            
            createShipPalette() {
                const palette = document.getElementById('shipPalette');
                palette.innerHTML = '';
                
                this.ships.forEach((shipType, index) => {
                    for (let i = 0; i < shipType.count; i++) {
                        const shipElement = document.createElement('div');
                        shipElement.className = 'ship';
                        shipElement.textContent = `${shipType.name} (${shipType.size})`;
                        shipElement.dataset.shipIndex = index;
                        shipElement.dataset.shipInstance = i;
                        
                        shipElement.addEventListener('click', () => {
                            if (!shipElement.classList.contains('placed')) {
                                document.querySelectorAll('.ship').forEach(s => s.classList.remove('selected'));
                                shipElement.classList.add('selected');
                                this.selectedShip = {
                                    typeIndex: index,
                                    instance: i,
                                    size: shipType.size
                                };
                                this.drawBoards();
                            }
                        });
                        
                        palette.appendChild(shipElement);
                    }
                });
            }
            
            handleMyBoardClick(event) {
                if (this.gamePhase !== 'setup') return;
                
                const rect = this.myBoardCanvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                const hex = this.getHexAtPosition(x, y, this.myBoardCanvas);
                
                // –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
                const debugInfo = document.getElementById('debugInfo');
                if (hex) {
                    debugInfo.textContent = `–ö–ª–∏–∫: x=${Math.floor(x)}, y=${Math.floor(y)} -> row=${hex.row}, col=${hex.col}`;
                    debugInfo.style.display = 'block';
                } else {
                    debugInfo.textContent = `–ö–ª–∏–∫: x=${Math.floor(x)}, y=${Math.floor(y)} -> –≤–Ω–µ –ø–æ–ª—è`;
                    debugInfo.style.display = 'block';
                }
                
                if (hex) {
                    // –ï—Å–ª–∏ –≤—ã–±—Ä–∞–Ω –∫–æ—Ä–∞–±–ª—å - –ø—ã—Ç–∞–µ–º—Å—è —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å
                    if (this.selectedShip) {
                        if (this.placeShip(hex.row, hex.col, this.selectedShip, this.shipOrientation)) {
                            const shipElement = document.querySelector(`.ship[data-ship-index="${this.selectedShip.typeIndex}"][data-ship-instance="${this.selectedShip.instance}"]`);
                            if (shipElement) {
                                shipElement.classList.add('placed');
                                shipElement.classList.remove('selected');
                            }
                            
                            this.selectedShip = null;
                            this.lastHoveredHex = null;
                            this.drawBoards();
                            this.updateScores();
                            
                            if (this.allShipsPlaced()) {
                                document.getElementById('startGame').style.display = 'block';
                                
                                if (this.isOnline && this.isHost) {
                                    this.sendData({
                                        type: 'ready',
                                        ships: this.myShips
                                    });
                                }
                            }
                        }
                    } else {
                        // –ï—Å–ª–∏ –∫–æ—Ä–∞–±–ª—å –Ω–µ –≤—ã–±—Ä–∞–Ω - –ø—ã—Ç–∞–µ–º—Å—è —É–¥–∞–ª–∏—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π
                        this.removeShipAt(hex.row, hex.col);
                    }
                }
            }
            
            handleOpponentBoardClick(event) {
                if (this.gamePhase !== 'battle' || this.currentPlayer !== 'me') return;
                
                const rect = this.opponentBoardCanvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                const hex = this.getHexAtPosition(x, y, this.opponentBoardCanvas);
                
                // –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
                const debugInfo = document.getElementById('debugInfo');
                if (hex) {
                    debugInfo.textContent = `–í—ã—Å—Ç—Ä–µ–ª: x=${Math.floor(x)}, y=${Math.floor(y)} -> row=${hex.row}, col=${hex.col}`;
                    debugInfo.style.display = 'block';
                } else {
                    debugInfo.textContent = `–í—ã—Å—Ç—Ä–µ–ª: x=${Math.floor(x)}, y=${Math.floor(y)} -> –≤–Ω–µ –ø–æ–ª—è`;
                    debugInfo.style.display = 'block';
                }
                
                if (hex && !this.isAlreadyShot(hex.row, hex.col, this.myShots)) {
                    this.makeShot(hex.row, hex.col);
                }
            }
            
            getHexAtPosition(x, y, canvas) {
                const hexSize = this.getHexSize(canvas);
                const hexHeight = hexSize * Math.sqrt(3);
                const hexWidth = hexSize * 2;
                
                // –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –≤—Å–µ–º –≥–µ–∫—Å–∞–º –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
                for (let row = 0; row < this.boardSize; row++) {
                    for (let col = 0; col < this.boardSize; col++) {
                        const hexX = col * hexWidth * 0.75 + hexWidth / 2;
                        const hexY = row * hexHeight + (col % 2) * hexHeight / 2 + hexHeight / 2;
                        
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–ø–∞–¥–∞–Ω–∏–µ –≤ –≥–µ–∫—Å
                        if (this.isPointInHex(x, y, hexX, hexY, hexSize)) {
                            return { row, col };
                        }
                    }
                }
                return null;
            }
            
            isPointInHex(x, y, hexX, hexY, hexSize) {
                // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≤ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–µ –∫ —Ü–µ–Ω—Ç—Ä—É –≥–µ–∫—Å–∞
                const dx = Math.abs(x - hexX);
                const dy = Math.abs(y - hexY);
                const hexHeight = hexSize * Math.sqrt(3);
                
                // –ü—Ä–æ—Å—Ç–∞—è –∏ –Ω–∞–¥–µ–∂–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è —à–µ—Å—Ç–∏—É–≥–æ–ª—å–Ω–∏–∫–∞
                if (dx > hexSize * 0.75) return false;
                if (dy > hexHeight * 0.5) return false;
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–∫–ª–æ–Ω–Ω—ã—Ö –≥—Ä–∞–Ω–µ–π
                return (dx * 0.577 + dy <= hexHeight * 0.5);
            }
            
            getHexSize(canvas) {
                return Math.min(canvas.width, canvas.height) / (this.boardSize * 2.2);
            }
            
            placeShip(row, col, ship, orientation) {
                const positions = this.getShipPositions(row, col, ship.size, orientation);
                
                if (!positions) return false;
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–æ—Ä–∞–±–ª—å –Ω–µ –ø–µ—Ä–µ—Å–µ–∫–∞–µ—Ç—Å—è —Å –¥—Ä—É–≥–∏–º–∏ –∏ –Ω–µ –∫–∞—Å–∞–µ—Ç—Å—è –∏—Ö
                if (!this.canPlaceShip(positions)) {
                    return false;
                }
                
                const shipData = {
                    positions: positions,
                    hits: Array(ship.size).fill(false),
                    size: ship.size,
                    typeIndex: ship.typeIndex,
                    instance: ship.instance
                };
                
                for (const pos of positions) {
                    this.myBoard[pos.row][pos.col] = 'ship';
                }
                
                this.myShips.push(shipData);
                return true;
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –∫–æ—Ä–∞–±–ª—è (–±–µ–∑ –∫–∞—Å–∞–Ω–∏—è –¥—Ä—É–≥–∏—Ö –∫–æ—Ä–∞–±–ª–µ–π)
            canPlaceShip(positions) {
                for (const pos of positions) {
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–ª–µ—Ç–∫–∞ —Å–≤–æ–±–æ–¥–Ω–∞
                    if (!this.isValidPosition(pos.row, pos.col) || this.myBoard[pos.row][pos.col] !== '') {
                        return false;
                    }
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ —Å–æ—Å–µ–¥–Ω–∏–µ –∫–ª–µ—Ç–∫–∏ (–≤–∫–ª—é—á–∞—è –¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω—ã–µ –≤ –≥–µ–∫—Å–∞–≥–æ–Ω–∞–ª—å–Ω–æ–π —Å–µ—Ç–∫–µ)
                    const neighbors = this.getNeighborCells(pos.row, pos.col);
                    for (const neighbor of neighbors) {
                        if (this.myBoard[neighbor.row][neighbor.col] === 'ship') {
                            return false;
                        }
                    }
                }
                return true;
            }
            
            // –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö —Å–æ—Å–µ–¥–Ω–∏—Ö –∫–ª–µ—Ç–æ–∫ (–≤–∫–ª—é—á–∞—è –¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω—ã–µ)
            getNeighborCells(row, col) {
                const neighbors = [];
                const directions = [
                    { dr: 0, dc: 1 },   // –í–ø—Ä–∞–≤–æ
                    { dr: -1, dc: 1 },  // –í–≤–µ—Ä—Ö-–≤–ø—Ä–∞–≤–æ
                    { dr: -1, dc: 0 },  // –í–≤–µ—Ä—Ö-–≤–ª–µ–≤–æ
                    { dr: 0, dc: -1 },  // –í–ª–µ–≤–æ
                    { dr: 1, dc: -1 },  // –í–Ω–∏–∑-–≤–ª–µ–≤–æ
                    { dr: 1, dc: 0 },   // –í–Ω–∏–∑-–≤–ø—Ä–∞–≤–æ
                    // –î–∏–∞–≥–æ–Ω–∞–ª—å–Ω—ã–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤ –≥–µ–∫—Å–∞–≥–æ–Ω–∞–ª—å–Ω–æ–π —Å–µ—Ç–∫–µ
                    { dr: -1, dc: 2 },  // –î–∏–∞–≥–æ–Ω–∞–ª—å
                    { dr: -2, dc: 1 },  // –î–∏–∞–≥–æ–Ω–∞–ª—å
                    { dr: -2, dc: -1 }, // –î–∏–∞–≥–æ–Ω–∞–ª—å
                    { dr: -1, dc: -2 }, // –î–∏–∞–≥–æ–Ω–∞–ª—å
                    { dr: 1, dc: -2 },  // –î–∏–∞–≥–æ–Ω–∞–ª—å
                    { dr: 2, dc: -1 },  // –î–∏–∞–≥–æ–Ω–∞–ª—å
                    { dr: 2, dc: 1 },   // –î–∏–∞–≥–æ–Ω–∞–ª—å
                    { dr: 1, dc: 2 }    // –î–∏–∞–≥–æ–Ω–∞–ª—å
                ];
                
                for (const dir of directions) {
                    const newRow = row + dir.dr;
                    const newCol = col + dir.dc;
                    
                    if (this.isValidPosition(newRow, newCol)) {
                        neighbors.push({ row: newRow, col: newCol });
                    }
                }
                
                return neighbors;
            }
            
            // –£–¥–∞–ª–µ–Ω–∏–µ –∫–æ—Ä–∞–±–ª—è –ø–æ –ø–æ–∑–∏—Ü–∏–∏
            removeShipAt(row, col) {
                if (this.myBoard[row][col] !== 'ship') return;
                
                // –ù–∞—Ö–æ–¥–∏–º –∫–æ—Ä–∞–±–ª—å, –∫–æ—Ç–æ—Ä—ã–π –∑–∞–Ω–∏–º–∞–µ—Ç —ç—Ç—É –∫–ª–µ—Ç–∫—É
                const shipIndex = this.myShips.findIndex(ship => 
                    ship.positions.some(pos => pos.row === row && pos.col === col)
                );
                
                if (shipIndex !== -1) {
                    const ship = this.myShips[shipIndex];
                    
                    // –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º –∫–ª–µ—Ç–∫–∏
                    for (const pos of ship.positions) {
                        this.myBoard[pos.row][pos.col] = '';
                    }
                    
                    // –£–¥–∞–ª—è–µ–º –∫–æ—Ä–∞–±–ª—å –∏–∑ –º–∞—Å—Å–∏–≤–∞
                    this.myShips.splice(shipIndex, 1);
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º –ø–∞–ª–∏—Ç—Ä—É
                    this.updateShipPalette();
                    
                    this.drawBoards();
                    this.updateScores();
                    
                    // –°–∫—Ä—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É –Ω–∞—á–∞–ª–∞ –∏–≥—Ä—ã, –µ—Å–ª–∏ –Ω–µ –≤—Å–µ –∫–æ—Ä–∞–±–ª–∏ —Ä–∞–∑–º–µ—â–µ–Ω—ã
                    if (!this.allShipsPlaced()) {
                        document.getElementById('startGame').style.display = 'none';
                    }
                }
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–∞–ª–∏—Ç—Ä—ã –∫–æ—Ä–∞–±–ª–µ–π
            updateShipPalette() {
                const palette = document.getElementById('shipPalette');
                const shipElements = palette.querySelectorAll('.ship');
                
                // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –≤—Å–µ –∫–æ—Ä–∞–±–ª–∏ –≤ –ø–∞–ª–∏—Ç—Ä–µ
                shipElements.forEach(shipElement => {
                    shipElement.classList.remove('placed');
                });
                
                // –ü–æ–º–µ—á–∞–µ–º —Ä–∞–∑–º–µ—â–µ–Ω–Ω—ã–µ –∫–æ—Ä–∞–±–ª–∏
                this.myShips.forEach(ship => {
                    const shipElement = document.querySelector(
                        `.ship[data-ship-index="${ship.typeIndex}"][data-ship-instance="${ship.instance}"]`
                    );
                    if (shipElement) {
                        shipElement.classList.add('placed');
                    }
                });
            }
            
            getShipPositions(row, col, size, orientation) {
                const positions = [{ row, col }];
                let currentRow = row;
                let currentCol = col;
                
                const directions = [
                    { dr: 0, dc: 1 },   // –í–ø—Ä–∞–≤–æ
                    { dr: -1, dc: 1 },  // –í–≤–µ—Ä—Ö-–≤–ø—Ä–∞–≤–æ
                    { dr: -1, dc: 0 },  // –í–≤–µ—Ä—Ö-–≤–ª–µ–≤–æ
                    { dr: 0, dc: -1 },  // –í–ª–µ–≤–æ
                    { dr: 1, dc: -1 },  // –í–Ω–∏–∑-–≤–ª–µ–≤–æ
                    { dr: 1, dc: 0 }    // –í–Ω–∏–∑-–≤–ø—Ä–∞–≤–æ
                ];
                
                const dir = directions[orientation];
                
                for (let i = 1; i < size; i++) {
                    currentRow += dir.dr;
                    currentCol += dir.dc;
                    
                    if (!this.isValidPosition(currentRow, currentCol)) {
                        return null;
                    }
                    
                    positions.push({ row: currentRow, col: currentCol });
                }
                
                return positions;
            }
            
            isValidPosition(row, col) {
                return row >= 0 && row < this.boardSize && col >= 0 && col < this.boardSize;
            }
            
            randomizeShips() {
                this.initializeGame();
                
                this.ships.forEach((shipType, typeIndex) => {
                    for (let i = 0; i < shipType.count; i++) {
                        let placed = false;
                        let attempts = 0;
                        
                        // –ü—ã—Ç–∞–µ–º—Å—è —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å –∫–æ—Ä–∞–±–ª—å, –ø–æ–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–º –≤–∞–ª–∏–¥–Ω—É—é –ø–æ–∑–∏—Ü–∏—é
                        while (!placed && attempts < 500) {
                            const row = Math.floor(Math.random() * this.boardSize);
                            const col = Math.floor(Math.random() * this.boardSize);
                            const orientation = Math.floor(Math.random() * 6);
                            
                            const ship = {
                                typeIndex: typeIndex,
                                instance: i,
                                size: shipType.size
                            };
                            
                            const positions = this.getShipPositions(row, col, ship.size, orientation);
                            
                            if (positions && this.canPlaceShip(positions)) {
                                // –†–∞–∑–º–µ—â–∞–µ–º –∫–æ—Ä–∞–±–ª—å
                                const shipData = {
                                    positions: positions,
                                    hits: Array(shipType.size).fill(false),
                                    size: shipType.size,
                                    typeIndex: typeIndex,
                                    instance: i
                                };
                                
                                for (const pos of positions) {
                                    this.myBoard[pos.row][pos.col] = 'ship';
                                }
                                
                                this.myShips.push(shipData);
                                placed = true;
                            }
                            attempts++;
                        }
                        
                        if (!placed) {
                            console.warn(`–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å –∫–æ—Ä–∞–±–ª—å ${shipType.name} (${shipType.size})`);
                        }
                    }
                });
                
                this.createShipPalette();
                this.drawBoards();
                this.updateScores();
                
                if (this.allShipsPlaced()) {
                    document.getElementById('startGame').style.display = 'block';
                    
                    if (this.isOnline && this.isHost) {
                        this.sendData({
                            type: 'ready',
                            ships: this.myShips
                        });
                    }
                }
            }
            
            allShipsPlaced() {
                let totalShips = 0;
                this.ships.forEach(shipType => {
                    totalShips += shipType.count;
                });
                
                return this.myShips.length === totalShips;
            }
            
            startBattle() {
                if (!this.allShipsPlaced()) return;
                
                this.gamePhase = 'battle';
                this.currentPlayer = 'me';
                this.updateGamePhase();
                this.drawBoards();
                
                if (this.isOnline) {
                    this.sendData({
                        type: 'start_battle'
                    });
                }
            }
            
            makeShot(row, col) {
                if (this.gamePhase !== 'battle') return;
                
                this.myShots.push({ row, col });
                
                let hit = false;
                let sunkShip = null;
                
                for (const ship of this.opponentShips) {
                    for (let i = 0; i < ship.positions.length; i++) {
                        const pos = ship.positions[i];
                        if (pos.row === row && pos.col === col) {
                            hit = true;
                            ship.hits[i] = true;
                            
                            if (ship.hits.every(h => h)) {
                                sunkShip = ship;
                            }
                            break;
                        }
                    }
                    if (hit) break;
                }
                
                this.opponentBoard[row][col] = hit ? 'hit' : 'miss';
                
                this.drawBoards();
                this.updateScores();
                
                if (this.checkGameOver()) {
                    this.gamePhase = 'gameover';
                    this.updateGamePhase();
                    setTimeout(() => alert('–í—ã –ø–æ–±–µ–¥–∏–ª–∏!'), 100);
                    return;
                }
                
                if (this.isOnline) {
                    this.sendData({
                        type: 'shot',
                        row: row,
                        col: col,
                        hit: hit,
                        sunkShip: sunkShip
                    });
                    
                    if (!hit) {
                        this.currentPlayer = 'opponent';
                        this.updateGamePhase();
                    }
                } else {
                    if (!hit) {
                        this.currentPlayer = 'opponent';
                        this.updateGamePhase();
                        setTimeout(() => this.makeBotMove(), 800);
                    }
                }
            }
            
            makeBotMove() {
                if (this.gamePhase !== 'battle' || this.currentPlayer !== 'opponent') return;
                
                let row, col;
                let attempts = 0;
                
                do {
                    row = Math.floor(Math.random() * this.boardSize);
                    col = Math.floor(Math.random() * this.boardSize);
                    attempts++;
                } while (this.isAlreadyShot(row, col, this.opponentShots) && attempts < 100);
                
                if (attempts < 100) {
                    this.receiveShot(row, col);
                }
            }
            
            receiveShot(row, col) {
                if (this.gamePhase !== 'battle') return;
                
                this.opponentShots.push({ row, col });
                
                let hit = false;
                let sunkShip = null;
                
                for (const ship of this.myShips) {
                    for (let i = 0; i < ship.positions.length; i++) {
                        const pos = ship.positions[i];
                        if (pos.row === row && pos.col === col) {
                            hit = true;
                            ship.hits[i] = true;
                            
                            if (ship.hits.every(h => h)) {
                                sunkShip = ship;
                            }
                            break;
                        }
                    }
                    if (hit) break;
                }
                
                this.myBoard[row][col] = hit ? 'hit' : 'miss';
                
                this.drawBoards();
                this.updateScores();
                
                if (this.checkGameOver()) {
                    this.gamePhase = 'gameover';
                    this.updateGamePhase();
                    setTimeout(() => alert('–ü—Ä–æ—Ç–∏–≤–Ω–∏–∫ –ø–æ–±–µ–¥–∏–ª!'), 100);
                    return;
                }
                
                if (this.isOnline) {
                    this.sendData({
                        type: 'shot_result',
                        row: row,
                        col: col,
                        hit: hit,
                        sunkShip: sunkShip
                    });
                    
                    if (!hit) {
                        this.currentPlayer = 'me';
                        this.updateGamePhase();
                    }
                } else {
                    if (!hit) {
                        this.currentPlayer = 'me';
                        this.updateGamePhase();
                    }
                }
            }
            
            isAlreadyShot(row, col, shots) {
                return shots.some(shot => shot.row === row && shot.col === col);
            }
            
            checkGameOver() {
                const myShipsSunk = this.myShips.every(ship => ship.hits.every(h => h));
                const opponentShipsSunk = this.opponentShips.every(ship => ship.hits.every(h => h));
                
                return myShipsSunk || opponentShipsSunk;
            }
            
            updateGamePhase() {
                const phaseElement = document.getElementById('gamePhase');
                
                switch (this.gamePhase) {
                    case 'setup':
                        phaseElement.textContent = '–§–∞–∑–∞ —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∏ –∫–æ—Ä–∞–±–ª–µ–π';
                        break;
                    case 'battle':
                        phaseElement.textContent = `–§–∞–∑–∞ –±–æ—è - –•–æ–¥: ${this.currentPlayer === 'me' ? '–í–∞—à' : '–ü—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞'}`;
                        break;
                    case 'gameover':
                        phaseElement.textContent = '–ò–≥—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞';
                        break;
                }
                
                document.getElementById('playerMe').classList.toggle('active', this.currentPlayer === 'me');
                document.getElementById('playerOpponent').classList.toggle('active', this.currentPlayer === 'opponent');
            }
            
            updateScores() {
                const myAliveShips = this.myShips.filter(ship => !ship.hits.every(h => h)).length;
                const opponentAliveShips = this.opponentShips.filter(ship => !ship.hits.every(h => h)).length;
                
                document.getElementById('scoreMe').textContent = `${myAliveShips} –∫–æ—Ä–∞–±–ª–µ–π`;
                document.getElementById('scoreOpponent').textContent = `${opponentAliveShips} –∫–æ—Ä–∞–±–ª–µ–π`;
            }
            
            drawBoards() {
                this.drawBoard(this.myCtx, this.myBoardCanvas, this.myBoard, this.myShips, true);
                this.drawBoard(this.opponentCtx, this.opponentBoardCanvas, this.opponentBoard, this.opponentShips, false);
            }
            
            drawBoard(ctx, canvas, board, ships, showShips) {
                const hexSize = this.getHexSize(canvas);
                const hexHeight = hexSize * Math.sqrt(3);
                const hexWidth = hexSize * 2;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // –î–æ–±–∞–≤–ª—è–µ–º –æ—Ç—Å—Ç—É–ø—ã –¥–ª—è —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è
                const offsetX = (canvas.width - (this.boardSize * hexWidth * 0.75 - hexWidth * 0.25)) / 2;
                const offsetY = (canvas.height - (this.boardSize * hexHeight + hexHeight * 0.5)) / 2;
                
                for (let row = 0; row < this.boardSize; row++) {
                    for (let col = 0; col < this.boardSize; col++) {
                        const x = offsetX + col * hexWidth * 0.75 + hexWidth / 2;
                        const y = offsetY + row * hexHeight + (col % 2) * hexHeight / 2 + hexHeight / 2;
                        
                        this.drawHex(ctx, x, y, hexSize, board[row][col], showShips, row, col);
                    }
                }
                
                // –†–∏—Å—É–µ–º –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –∫–æ—Ä–∞–±–ª—è
                if (this.gamePhase === 'setup' && this.selectedShip && showShips && this.lastHoveredHex) {
                    const positions = this.getShipPositions(this.lastHoveredHex.row, this.lastHoveredHex.col, this.selectedShip.size, this.shipOrientation);
                    if (positions) {
                        let valid = this.canPlaceShip(positions);
                        
                        ctx.globalAlpha = 0.6;
                        for (const pos of positions) {
                            const x = offsetX + pos.col * hexWidth * 0.75 + hexWidth / 2;
                            const y = offsetY + pos.row * hexHeight + (pos.col % 2) * hexHeight / 2 + hexHeight / 2;
                            this.drawHex(ctx, x, y, hexSize, valid ? 'ship-preview' : 'invalid-preview', showShips, pos.row, pos.col);
                        }
                        ctx.globalAlpha = 1.0;
                    }
                }
            }
            
            drawHex(ctx, x, y, hexSize, state, showShips, row, col) {
                // –†–∏—Å—É–µ–º —à–µ—Å—Ç–∏—É–≥–æ–ª—å–Ω–∏–∫
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = Math.PI / 3 * i;
                    const hexX = x + hexSize * Math.cos(angle);
                    const hexY = y + hexSize * Math.sin(angle);
                    if (i === 0) ctx.moveTo(hexX, hexY);
                    else ctx.lineTo(hexX, hexY);
                }
                ctx.closePath();
                
                switch (state) {
                    case 'ship':
                        if (showShips) {
                            ctx.fillStyle = '#4CAF50';
                        } else {
                            ctx.fillStyle = 'rgba(0, 0, 50, 0.7)';
                        }
                        break;
                    case 'hit':
                        ctx.fillStyle = '#FF5252';
                        break;
                    case 'miss':
                        ctx.fillStyle = '#2196F3';
                        break;
                    case 'ship-preview':
                        ctx.fillStyle = 'rgba(76, 175, 80, 0.4)';
                        break;
                    case 'invalid-preview':
                        ctx.fillStyle = 'rgba(255, 82, 82, 0.4)';
                        break;
                    default:
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
                }
                
                ctx.fill();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // –†–∏—Å—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∫–ª–µ—Ç–∫–∏ –º–µ–ª–∫–∏–º —à—Ä–∏—Ñ—Ç–æ–º
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = `${Math.max(8, hexSize * 0.15)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º row –∏ col
                const coordText = `${row},${col}`;
                ctx.fillText(coordText, x, y);
                
                if (state === 'hit') {
                    ctx.strokeStyle = '#FFF';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x - hexSize * 0.3, y - hexSize * 0.3);
                    ctx.lineTo(x + hexSize * 0.3, y + hexSize * 0.3);
                    ctx.moveTo(x + hexSize * 0.3, y - hexSize * 0.3);
                    ctx.lineTo(x - hexSize * 0.3, y + hexSize * 0.3);
                    ctx.stroke();
                }
                
                if (state === 'miss') {
                    ctx.fillStyle = '#2196F3';
                    ctx.beginPath();
                    ctx.arc(x, y, hexSize * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // –û–ù–õ–ê–ô–ù-–§–£–ù–ö–¶–ò–û–ù–ê–õ–¨–ù–û–°–¢–¨ (–æ—Å—Ç–∞–µ—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
            createOnlineGame() {
                this.isOnline = true;
                this.isHost = true;
                
                this.peer = new Peer({
                    host: '0.peerjs.com',
                    port: 443,
                    path: '/',
                    pingInterval: 5000
                });
                
                this.peer.on('open', (id) => {
                    this.roomId = id;
                    this.updateConnectionStatus(`–ö–æ–º–Ω–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∞! ID: ${id}`, 'success');
                    document.getElementById('roomInfo').innerHTML = `ID –∫–æ–º–Ω–∞—Ç—ã: <strong>${id}</strong><br>–û–∂–∏–¥–∞–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è...`;
                    document.getElementById('roomInfo').style.display = 'block';
                });
                
                this.peer.on('connection', (conn) => {
                    this.connection = conn;
                    this.setupConnection();
                    this.updateConnectionStatus('–ò–≥—Ä–æ–∫ –ø–æ–¥–∫–ª—é—á–µ–Ω!', 'success');
                });
                
                this.peer.on('error', (err) => {
                    console.error('Peer error:', err);
                    this.updateConnectionStatus('–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: ' + err.type, 'error');
                });
            }
            
            joinOnlineGame() {
                const roomId = document.getElementById('roomIdInput').value.trim();
                if (!roomId) {
                    alert('–í–≤–µ–¥–∏—Ç–µ ID –∫–æ–º–Ω–∞—Ç—ã');
                    return;
                }
                
                this.isOnline = true;
                this.isHost = false;
                
                this.peer = new Peer({
                    host: '0.peerjs.com',
                    port: 443,
                    path: '/',
                    pingInterval: 5000
                });
                
                this.peer.on('open', (id) => {
                    this.roomId = roomId;
                    this.connection = this.peer.connect(roomId);
                    this.setupConnection();
                    this.updateConnectionStatus('–ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ –∫–æ–º–Ω–∞—Ç–µ...', 'info');
                });
                
                this.peer.on('error', (err) => {
                    console.error('Peer error:', err);
                    this.updateConnectionStatus('–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: ' + err.type, 'error');
                });
            }
            
            setupConnection() {
                this.connection.on('open', () => {
                    this.updateConnectionStatus('–ü–æ–¥–∫–ª—é—á–µ–Ω–æ!', 'success');
                    if (!this.isHost) {
                        this.sendData({ type: 'request_state' });
                    }
                });
                
                this.connection.on('data', (data) => {
                    this.handleOnlineData(data);
                });
                
                this.connection.on('close', () => {
                    this.updateConnectionStatus('–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Ä–∞–∑–æ—Ä–≤–∞–Ω–æ', 'error');
                    this.leaveOnlineGame();
                });
                
                this.connection.on('error', (err) => {
                    console.error('Connection error:', err);
                    this.updateConnectionStatus('–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è', 'error');
                });
            }
            
            handleOnlineData(data) {
                console.log("–ü–æ–ª—É—á–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ:", data);
                
                switch (data.type) {
                    case 'ready':
                        if (this.isHost) {
                            this.opponentShips = data.ships;
                            this.sendData({
                                type: 'game_state',
                                ships: this.myShips,
                                gamePhase: this.gamePhase
                            });
                        }
                        break;
                        
                    case 'game_state':
                        this.opponentShips = data.ships;
                        this.gamePhase = data.gamePhase;
                        this.updateGamePhase();
                        this.drawBoards();
                        break;
                        
                    case 'start_battle':
                        this.startBattle();
                        break;
                        
                    case 'shot':
                        this.receiveShot(data.row, data.col);
                        break;
                        
                    case 'shot_result':
                        this.opponentBoard[data.row][data.col] = data.hit ? 'hit' : 'miss';
                        
                        if (data.sunkShip) {
                            this.opponentShips.forEach(ship => {
                                if (ship.typeIndex === data.sunkShip.typeIndex && 
                                    ship.instance === data.sunkShip.instance) {
                                    ship.hits = data.sunkShip.hits;
                                }
                            });
                        }
                        
                        this.drawBoards();
                        this.updateScores();
                        
                        if (!data.hit) {
                            this.currentPlayer = 'me';
                            this.updateGamePhase();
                        }
                        break;
                        
                    case 'request_state':
                        if (this.isHost) {
                            this.sendData({
                                type: 'game_state',
                                ships: this.myShips,
                                gamePhase: this.gamePhase
                            });
                        }
                        break;
                }
            }
            
            sendData(data) {
                if (this.connection && this.connection.open) {
                    this.connection.send(data);
                    return true;
                } else {
                    console.warn("–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –Ω–µ –æ—Ç–∫—Ä—ã—Ç–æ, –¥–∞–Ω–Ω—ã–µ –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã");
                    this.updateConnectionStatus("–û—à–∏–±–∫–∞: –Ω–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è", "error");
                    return false;
                }
            }
            
            updateConnectionStatus(message, type) {
                const statusElement = document.getElementById('connectionStatus');
                statusElement.textContent = message;
                statusElement.style.display = 'block';
                statusElement.style.background = type === 'success' ? 'rgba(212, 237, 218, 0.2)' : 
                                               type === 'error' ? 'rgba(248, 215, 218, 0.2)' : 'rgba(209, 236, 241, 0.2)';
                statusElement.style.color = type === 'success' ? '#d4edda' : 
                                           type === 'error' ? '#f8d7da' : '#d1ecf1';
            }
            
            leaveOnlineGame() {
                if (this.connection) {
                    this.connection.close();
                }
                if (this.peer) {
                    this.peer.destroy();
                }
                this.isOnline = false;
                this.initializeGame();
            }
        }

        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –∫–Ω–æ–ø–æ–∫ HTML
        function createOnlineGame() {
            const game = document.querySelector('script')._gameInstance;
            if (game) {
                game.createOnlineGame();
            }
        }

        function joinOnlineGame() {
            const game = document.querySelector('script')._gameInstance;
            if (game) {
                game.joinOnlineGame();
            }
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã
        document.addEventListener('DOMContentLoaded', () => {
            const game = new HexagonalBattleship();
            document.querySelector('script')._gameInstance = game;
        });
    </script>
</body>
</html>