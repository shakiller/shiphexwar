<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ì–µ–∫—Å–∞–≥–æ–Ω–∞–ª—å–Ω—ã–π –ú–æ—Ä—Å–∫–æ–π –ë–æ–π</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        /* –°—Ç–∏–ª–∏ –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: white;
        }

        .container {
            max-width: 1200px;
            width: 100%;
            text-align: center;
        }

        h1 {
            color: white;
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .game-info {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }

        .players {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
        }

        .player {
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.2em;
            font-weight: bold;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.1);
            position: relative;
            border: 2px solid transparent;
        }

        .player.active {
            background: rgba(76, 175, 80, 0.3);
            border: 2px solid #4CAF50;
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }

        .player.me { border-left: 4px solid #4CAF50; }
        .player.opponent { border-left: 4px solid #FF5252; }

        .score {
            font-size: 1.5em;
            color: #fff;
            margin-top: 5px;
        }

        .controls {
            margin: 20px 0;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 25px;
            border: none;
            border-radius: 5px;
            font-size: 1em;
            background: #4CAF50;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        button:hover {
            background: #45a049;
            transform: translateY(-2px);
        }

        .rotation-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        .rotation-btn {
            background: #2196F3;
            padding: 8px 15px;
            font-size: 0.9em;
        }

        .rotation-info {
            font-size: 0.9em;
            color: #FFD700;
            font-weight: bold;
        }

        .direction-hint {
            color: #FFD700;
            font-size: 0.8em;
            margin-top: 5px;
            background: rgba(255, 215, 0, 0.1);
            padding: 5px;
            border-radius: 5px;
        }

        .game-boards {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .board-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            position: relative;
        }

        .board-title {
            margin-bottom: 10px;
            font-size: 1.2em;
            font-weight: bold;
        }

        .canvas-container {
            position: relative;
            display: inline-block;
        }

        canvas {
            display: block;
            cursor: pointer;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(0, 0, 50, 0.7);
            border-radius: 10px;
            width: 500px;
            height: 500px;
        }

        .ship-palette {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 12px;
            flex-wrap: wrap;
        }

        .ship {
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
        }

        .ship.selected {
            background: rgba(76, 175, 80, 0.5);
            border: 2px solid #4CAF50;
        }

        .ship.placed {
            background: rgba(100, 100, 100, 0.5);
            cursor: not-allowed;
        }

        .online-buttons {
            text-align: center;
            margin: 15px 0;
        }

        .online-buttons input {
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 0.9em;
            margin: 5px;
            background: rgba(255, 255, 255, 0.9);
        }

        #connectionStatus {
            transition: all 0.3s ease;
            padding: 8px;
            border-radius: 5px;
            margin-top: 8px;
            display: none;
            font-size: 0.9em;
        }

        #roomInfo {
            background: rgba(233, 236, 239, 0.2);
            padding: 8px;
            border-radius: 5px;
            border-left: 4px solid #4CAF50;
            margin-top: 8px;
            display: none;
            font-size: 0.9em;
        }

        .game-phase {
            font-size: 1.1em;
            margin: 12px 0;
            font-weight: bold;
            color: #FFD700;
        }

        .instructions {
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            border-radius: 10px;
            margin-top: 15px;
            font-size: 0.85em;
            color: #ccc;
            backdrop-filter: blur(10px);
        }

        .delete-hint {
            color: #FF5252;
            font-size: 0.8em;
            margin-top: 5px;
        }

        .debug-info {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-size: 0.9em;
            color: #fff;
            border-left: 3px solid #4CAF50;
            display: none;
        }

        .mouse-coords {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px;
            border-radius: 3px;
            font-size: 0.7em;
            color: white;
        }

        .last-click-info {
            background: rgba(255, 215, 0, 0.2);
            padding: 8px;
            border-radius: 5px;
            margin-top: 8px;
            font-size: 0.9em;
            color: #FFD700;
            border-left: 3px solid #FFD700;
        }

        .touch-zones-toggle {
            background: #9C27B0;
            padding: 8px 15px;
            font-size: 0.9em;
            margin-top: 10px;
        }

        .coords-debug {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-size: 0.8em;
            color: #ccc;
            font-family: monospace;
        }

        /* –ú–µ–¥–∏–∞-–∑–∞–ø—Ä–æ—Å—ã –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤ */
        @media (max-width: 768px) {
            .game-boards {
                flex-direction: column;
                align-items: center;
            }
            
            .board-container {
                margin-bottom: 15px;
            }
            
            canvas {
                width: 350px !important;
                height: 350px !important;
            }
            
            .players {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚öì –ì–µ–∫—Å–∞–≥–æ–Ω–∞–ª—å–Ω—ã–π –ú–æ—Ä—Å–∫–æ–π –ë–æ–π</h1>
        
        <div class="game-info">
            <div class="game-mode">
                <button class="mode-btn active" id="modeLocal">üë• –õ–æ–∫–∞–ª—å–Ω–∞—è –∏–≥—Ä–∞</button>
                <button class="mode-btn" id="modeOnline">üåê –û–Ω–ª–∞–π–Ω –∏–≥—Ä–∞</button>
            </div>
            
            <div id="onlineLobby" style="display: none;">
                <h3>–û–Ω–ª–∞–π–Ω –∏–≥—Ä–∞</h3>
                <div class="online-buttons">
                    <button onclick="createOnlineGame()" class="control-btn">–°–æ–∑–¥–∞—Ç—å –∫–æ–º–Ω–∞—Ç—É</button>
                    <div style="margin: 8px 0; text-align: center">–∏–ª–∏</div>
                    <input type="text" id="roomIdInput" placeholder="ID –∫–æ–º–Ω–∞—Ç—ã">
                    <button onclick="joinOnlineGame()" class="control-btn">–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è</button>
                </div>
                <div id="connectionStatus"></div>
                <div id="roomInfo"></div>
            </div>
            
            <div class="players">
                <div class="player me" id="playerMe">
                    –í–∞—à —Ñ–ª–æ—Ç
                    <div class="score" id="scoreMe">0 –∫–æ—Ä–∞–±–ª–µ–π</div>
                </div>
                <div class="player opponent" id="playerOpponent">
                    –§–ª–æ—Ç –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞
                    <div class="score" id="scoreOpponent">0 –∫–æ—Ä–∞–±–ª–µ–π</div>
                </div>
            </div>
            
            <div class="game-phase" id="gamePhase">–§–∞–∑–∞ —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∏ –∫–æ—Ä–∞–±–ª–µ–π</div>
            
            <div class="controls">
                <button id="randomShips">–°–ª—É—á–∞–π–Ω–∞—è —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∞</button>
                <button id="startGame" style="display: none;">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
                <button id="newGameBtn">–ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
                <button id="toggleTouchZones" class="touch-zones-toggle">–ü–æ–∫–∞–∑–∞—Ç—å –∑–æ–Ω—ã –∫–ª–∏–∫–∞</button>
            </div>

            <div class="rotation-controls">
                <button class="rotation-btn" id="rotateLeft">‚Ü∂ –ü–æ–≤–µ—Ä–Ω—É—Ç—å –≤–ª–µ–≤–æ</button>
                <div class="rotation-info" id="rotationInfo">–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: ‚Üò</div>
                <button class="rotation-btn" id="rotateRight">–ü–æ–≤–µ—Ä–Ω—É—Ç—å –≤–ø—Ä–∞–≤–æ ‚Ü∑</button>
            </div>
            
            <div class="direction-hint">
                üí° –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤ –≥–µ–∫—Å–∞–≥–æ–Ω–∞–ª—å–Ω–æ–π —Å–µ—Ç–∫–µ: ‚Üì (–≤–µ—Ä—Ç–∏–∫–∞–ª—å), ‚Üò (–¥–∏–∞–≥–æ–Ω–∞–ª—å), ‚Üô (–¥–∏–∞–≥–æ–Ω–∞–ª—å), ‚Üë (–≤–µ—Ä—Ç–∏–∫–∞–ª—å), ‚Üñ (–¥–∏–∞–≥–æ–Ω–∞–ª—å), ‚Üó (–¥–∏–∞–≥–æ–Ω–∞–ª—å)
            </div>
            
            <div class="ship-palette" id="shipPalette">
                <!-- –ö–æ—Ä–∞–±–ª–∏ –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª–µ–Ω—ã –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ -->
            </div>
            <div class="delete-hint">üí° –î–ª—è —É–¥–∞–ª–µ–Ω–∏—è –∫–æ—Ä–∞–±–ª—è –∫–ª–∏–∫–Ω–∏—Ç–µ –ø–æ –Ω–µ–º—É –Ω–∞ –ø–æ–ª–µ</div>
            
            <!-- –ë–ª–æ–∫ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø–æ—Å–ª–µ–¥–Ω–µ–º –∫–ª–∏–∫–µ -->
            <div class="last-click-info" id="lastClickInfo" style="display: none;">
                –ü–æ—Å–ª–µ–¥–Ω—è—è –Ω–∞–∂–∞—Ç–∞—è –∫–ª–µ—Ç–∫–∞: <span id="lastClickCoords">-</span>
            </div>
            
            <div class="coords-debug" id="coordsDebug">
                –û—Ç–ª–∞–¥–∫–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç: <span id="coordsInfo">-</span>
            </div>
            
            <div class="debug-info" id="debugInfo"></div>
        </div>

        <div class="game-boards">
            <div class="board-container">
                <div class="board-title">–í–∞—à–µ –ø–æ–ª–µ</div>
                <div class="canvas-container">
                    <div class="mouse-coords" id="myBoardCoords">x: 0, y: 0</div>
                    <canvas id="myBoard"></canvas>
                </div>
            </div>
            <div class="board-container">
                <div class="board-title">–ü–æ–ª–µ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞</div>
                <div class="canvas-container">
                    <div class="mouse-coords" id="opponentBoardCoords">x: 0, y: 0</div>
                    <canvas id="opponentBoard"></canvas>
                </div>
            </div>
        </div>

        <div class="instructions">
            <p><strong>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ:</strong> –ö–ª–∏–∫–Ω–∏—Ç–µ –Ω–∞ –∫–æ—Ä–∞–±–ª—å –≤ –ø–∞–ª–∏—Ç—Ä–µ, –∑–∞—Ç–µ–º –Ω–∞ –ø–æ–ª–µ –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –ø–æ–≤–æ—Ä–æ—Ç–∞ –∏–ª–∏ –∫–ª–∞–≤–∏—à—É R.</p>
            <p><strong>–¶–µ–ª—å:</strong> –ü–µ—Ä–≤—ã–º –ø–æ—Ç–æ–ø–∏—Ç–µ –≤—Å–µ –∫–æ—Ä–∞–±–ª–∏ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞!</p>
        </div>
    </div>

    <script>
        class HexagonalBattleship {
            constructor() {
                this.myBoardCanvas = document.getElementById('myBoard');
                this.opponentBoardCanvas = document.getElementById('opponentBoard');
                this.myCtx = this.myBoardCanvas.getContext('2d');
                this.opponentCtx = this.opponentBoardCanvas.getContext('2d');
                
                // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ —Ä–∞–∑–º–µ—Ä—ã canvas —Ä–∞–≤–Ω—ã–º–∏ CSS —Ä–∞–∑–º–µ—Ä–∞–º
                this.setCanvasSize(this.myBoardCanvas, 500, 500);
                this.setCanvasSize(this.opponentBoardCanvas, 500, 500);
                
                // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –º—ã—à–∏
                this.currentMouseX = 0;
                this.currentMouseY = 0;
                this.lastHoveredHex = null;
                
                // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –ø–æ–¥—Å–≤–µ—Ç–∫–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∫–ª–∏–∫–∞
                this.lastClickedHexMyBoard = null;
                this.lastClickedHexOpponentBoard = null;
                
                // –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∑–æ–Ω –∫–ª–∏–∫–∞
                this.showTouchZones = false;
                
                // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–≥—Ä—ã
                this.boardSize = 8;
                this.ships = [
                    { size: 4, count: 1, name: "–õ–∏–Ω–∫–æ—Ä" },
                    { size: 3, count: 2, name: "–ö—Ä–µ–π—Å–µ—Ä" },
                    { size: 2, count: 3, name: "–≠—Å–º–∏–Ω–µ—Ü" },
                    { size: 1, count: 4, name: "–ö–∞—Ç–µ—Ä" }
                ];
                
                // –ò–≥—Ä–æ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
                this.myBoard = [];
                this.opponentBoard = [];
                this.myShips = [];
                this.opponentShips = [];
                this.myShots = [];
                this.opponentShots = [];
                this.currentPlayer = 'me';
                this.gamePhase = 'setup';
                this.selectedShip = null;
                this.shipOrientation = 0;
                
                // –ü–†–ê–í–ò–õ–¨–ù–´–ï –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–ª—è –≥–µ–∫—Å–∞–≥–æ–Ω–∞–ª—å–Ω–æ–π —Å–µ—Ç–∫–∏
                this.directionNames = ['‚Üì', '‚Üò', '‚Üô', '‚Üë', '‚Üñ', '‚Üó'];
                
                // –û–Ω–ª–∞–π–Ω-–ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
                this.peer = null;
                this.connection = null;
                this.isOnline = false;
                this.isHost = false;
                this.roomId = null;
                
                this.initializeGame();
                this.setupEventListeners();
                this.createShipPalette();
                this.drawBoards();
            }
            
            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã canvas —Å —É—á–µ—Ç–æ–º devicePixelRatio
            setCanvasSize(canvas, width, height) {
                const dpr = window.devicePixelRatio || 1;
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';
                canvas.width = width * dpr;
                canvas.height = height * dpr;
                const ctx = canvas.getContext('2d');
                ctx.scale(dpr, dpr);
            }
            
            // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –º—ã—à–∏ –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã canvas
            getMousePos(canvas, evt) {
                const rect = canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                return {
                    x: (evt.clientX - rect.left) * (canvas.width / rect.width / dpr),
                    y: (evt.clientY - rect.top) * (canvas.height / rect.height / dpr)
                };
            }
            
            initializeGame() {
                this.myBoard = Array(this.boardSize).fill().map(() => Array(this.boardSize).fill(''));
                this.opponentBoard = Array(this.boardSize).fill().map(() => Array(this.boardSize).fill(''));
                
                this.myShips = [];
                this.opponentShips = [];
                this.myShots = [];
                this.opponentShots = [];
                this.currentPlayer = 'me';
                this.gamePhase = 'setup';
                this.selectedShip = null;
                this.shipOrientation = 0;
                this.lastHoveredHex = null;
                this.lastClickedHexMyBoard = null;
                this.lastClickedHexOpponentBoard = null;
                
                this.updateGamePhase();
                this.updateScores();
                this.updateRotationInfo();
                this.updateLastClickInfo();
                this.drawBoards();
                this.createShipPalette();
                
                document.getElementById('startGame').style.display = this.isOnline ? 'none' : 'block';
            }
            
            setupEventListeners() {
                // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–ª–∏–∫–æ–≤ —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
                this.myBoardCanvas.addEventListener('click', (e) => {
                    const pos = this.getMousePos(this.myBoardCanvas, e);
                    this.handleMyBoardClick(pos.x, pos.y);
                });
                
                this.opponentBoardCanvas.addEventListener('click', (e) => {
                    const pos = this.getMousePos(this.opponentBoardCanvas, e);
                    this.handleOpponentBoardClick(pos.x, pos.y);
                });
                
                // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–≤–∏–∂–µ–Ω–∏—è –º—ã—à–∏ –¥–ª—è –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞
                this.myBoardCanvas.addEventListener('mousemove', (e) => {
                    const pos = this.getMousePos(this.myBoardCanvas, e);
                    this.currentMouseX = pos.x;
                    this.currentMouseY = pos.y;
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –Ω–∞ –¥–∏—Å–ø–ª–µ–µ
                    document.getElementById('myBoardCoords').textContent = 
                        `x: ${Math.floor(pos.x)}, y: ${Math.floor(pos.y)}`;
                    
                    this.handleMouseMove(pos.x, pos.y, this.myBoardCanvas);
                });
                
                this.opponentBoardCanvas.addEventListener('mousemove', (e) => {
                    const pos = this.getMousePos(this.opponentBoardCanvas, e);
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –Ω–∞ –¥–∏—Å–ø–ª–µ–µ
                    document.getElementById('opponentBoardCoords').textContent = 
                        `x: ${Math.floor(pos.x)}, y: ${Math.floor(pos.y)}`;
                });
                
                // –£–±–∏—Ä–∞–µ–º –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –ø—Ä–∏ —É—Ö–æ–¥–µ –º—ã—à–∏ —Å –ø–æ–ª—è
                this.myBoardCanvas.addEventListener('mouseleave', () => {
                    this.lastHoveredHex = null;
                    this.drawBoards();
                });

                // –û—Å—Ç–∞–ª—å–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
                document.getElementById('modeLocal').addEventListener('click', () => this.setGameMode('local'));
                document.getElementById('modeOnline').addEventListener('click', () => this.setGameMode('online'));
                document.getElementById('randomShips').addEventListener('click', () => this.randomizeShips());
                document.getElementById('startGame').addEventListener('click', () => this.startBattle());
                document.getElementById('newGameBtn').addEventListener('click', () => this.initializeGame());
                document.getElementById('rotateLeft').addEventListener('click', () => this.rotateLeft());
                document.getElementById('rotateRight').addEventListener('click', () => this.rotateRight());
                document.getElementById('toggleTouchZones').addEventListener('click', () => this.toggleTouchZones());
                
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'r' || e.key === '–∫' || e.key === 'R' || e.key === '–ô') {
                        this.rotateRight();
                    }
                    if (e.key === 'q' || e.key === '–π' || e.key === 'Q' || e.key === '–ô') {
                        this.rotateLeft();
                    }
                });

                window.addEventListener('resize', () => {
                    this.drawBoards();
                });
            }
            
            toggleTouchZones() {
                this.showTouchZones = !this.showTouchZones;
                document.getElementById('toggleTouchZones').textContent = 
                    this.showTouchZones ? '–°–∫—Ä—ã—Ç—å –∑–æ–Ω—ã –∫–ª–∏–∫–∞' : '–ü–æ–∫–∞–∑–∞—Ç—å –∑–æ–Ω—ã –∫–ª–∏–∫–∞';
                this.drawBoards();
            }
            
            handleMouseMove(x, y, canvas) {
                if (this.gamePhase !== 'setup' || !this.selectedShip) return;
                
                const hex = this.getHexAtPosition(x, y, canvas);
                if (hex && (this.lastHoveredHex === null || hex.row !== this.lastHoveredHex.row || hex.col !== this.lastHoveredHex.col)) {
                    this.lastHoveredHex = hex;
                    this.drawBoards();
                }
            }
            
            rotateLeft() {
                this.shipOrientation = (this.shipOrientation + 5) % 6;
                this.updateRotationInfo();
                this.drawBoards();
            }
            
            rotateRight() {
                this.shipOrientation = (this.shipOrientation + 1) % 6;
                this.updateRotationInfo();
                this.drawBoards();
            }
            
            updateRotationInfo() {
                const rotationInfo = document.getElementById('rotationInfo');
                rotationInfo.textContent = `–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: ${this.directionNames[this.shipOrientation]}`;
            }
            
            updateLastClickInfo() {
                const lastClickInfo = document.getElementById('lastClickInfo');
                const lastClickCoords = document.getElementById('lastClickCoords');
                
                let infoText = '';
                
                if (this.lastClickedHexMyBoard) {
                    infoText += `–í–∞—à–µ –ø–æ–ª–µ: [${this.lastClickedHexMyBoard.row},${this.lastClickedHexMyBoard.col}] `;
                }
                
                if (this.lastClickedHexOpponentBoard) {
                    infoText += `–ü–æ–ª–µ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞: [${this.lastClickedHexOpponentBoard.row},${this.lastClickedHexOpponentBoard.col}]`;
                }
                
                if (infoText) {
                    lastClickCoords.textContent = infoText;
                    lastClickInfo.style.display = 'block';
                } else {
                    lastClickInfo.style.display = 'none';
                }
            }
            
            setGameMode(mode) {
                this.isOnline = mode === 'online';
                document.getElementById('onlineLobby').style.display = this.isOnline ? 'block' : 'none';
                
                document.getElementById('modeLocal').classList.toggle('active', mode === 'local');
                document.getElementById('modeOnline').classList.toggle('active', mode === 'online');
                
                if (mode === 'local') {
                    this.leaveOnlineGame();
                }
            }
            
            createShipPalette() {
                const palette = document.getElementById('shipPalette');
                palette.innerHTML = '';
                
                this.ships.forEach((shipType, index) => {
                    for (let i = 0; i < shipType.count; i++) {
                        const shipElement = document.createElement('div');
                        shipElement.className = 'ship';
                        shipElement.textContent = `${shipType.name} (${shipType.size})`;
                        shipElement.dataset.shipIndex = index;
                        shipElement.dataset.shipInstance = i;
                        
                        shipElement.addEventListener('click', () => {
                            if (!shipElement.classList.contains('placed')) {
                                document.querySelectorAll('.ship').forEach(s => s.classList.remove('selected'));
                                shipElement.classList.add('selected');
                                this.selectedShip = {
                                    typeIndex: index,
                                    instance: i,
                                    size: shipType.size
                                };
                                this.drawBoards();
                            }
                        });
                        
                        palette.appendChild(shipElement);
                    }
                });
            }
            
            // –û–ë–©–ò–ô –ú–ï–¢–û–î –î–õ–Ø –í–´–ß–ò–°–õ–ï–ù–ò–Ø –ö–û–û–†–î–ò–ù–ê–¢ –ì–ï–ö–°–ê
            getHexCenter(row, col, canvas) {
                const hexSize = 30; // –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–∞–∑–º–µ—Ä –¥–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã
                const hexHeight = hexSize * Math.sqrt(3);
                const hexWidth = hexSize * 2;
                
                // –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã canvas (—É–∂–µ —Å —É—á–µ—Ç–æ–º DPR)
                const canvasWidth = canvas.width / (window.devicePixelRatio || 1);
                const canvasHeight = canvas.height / (window.devicePixelRatio || 1);
                
                const totalWidth = this.boardSize * hexWidth * 0.75 - hexWidth * 0.25;
                const totalHeight = this.boardSize * hexHeight + hexHeight * 0.5;
                
                const offsetX = (canvasWidth - totalWidth) / 2;
                const offsetY = (canvasHeight - totalHeight) / 2;
                
                const x = offsetX + col * hexWidth * 0.75 + hexWidth / 2;
                const y = offsetY + row * hexHeight + (col % 2) * hexHeight / 2 + hexHeight / 2;
                
                return { x, y, hexSize };
            }

            // –£–ü–†–û–©–ï–ù–ù–´–ô –ú–ï–¢–û–î –û–ü–†–ï–î–ï–õ–ï–ù–ò–Ø –Ø–ß–ï–ô–ö–ò
            getHexAtPosition(x, y, canvas) {
                // –ü—Ä–æ—Å—Ç–æ–π –ø–µ—Ä–µ–±–æ—Ä –≤—Å–µ—Ö —è—á–µ–µ–∫
                for (let row = 0; row < this.boardSize; row++) {
                    for (let col = 0; col < this.boardSize; col++) {
                        const center = this.getHexCenter(row, col, canvas);
                        const distance = Math.sqrt((x - center.x) ** 2 + (y - center.y) ** 2);
                        
                        if (distance < center.hexSize * 0.9) {
                            document.getElementById('coordsInfo').textContent = 
                                `–Ø—á–µ–π–∫–∞ [${row},${col}] | –¶–µ–Ω—Ç—Ä: [${Math.floor(center.x)},${Math.floor(center.y)}] | ` +
                                `–ö–ª–∏–∫: [${Math.floor(x)},${Math.floor(y)}] | –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ: ${Math.floor(distance)}`;
                            return { row, col, hexX: center.x, hexY: center.y, distance };
                        }
                    }
                }
                
                document.getElementById('coordsInfo').textContent = 
                    `–ö–ª–∏–∫: [${Math.floor(x)},${Math.floor(y)}] | –Ø–ß–ï–ô–ö–ê –ù–ï –ù–ê–ô–î–ï–ù–ê`;
                return null;
            }
            
            handleMyBoardClick(x, y) {
                if (this.gamePhase !== 'setup') return;
                
                console.log('=== –ö–õ–ò–ö –ü–û –ú–û–ï–ú–£ –ü–û–õ–Æ ===');
                console.log('–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –º—ã—à–∏:', x, y);
                console.log('–†–∞–∑–º–µ—Ä canvas:', this.myBoardCanvas.width, this.myBoardCanvas.height);
                
                const hex = this.getHexAtPosition(x, y, this.myBoardCanvas);
                
                const debugInfo = document.getElementById('debugInfo');
                
                if (hex) {
                    console.log('–ù–∞–π–¥–µ–Ω–∞ —è—á–µ–π–∫–∞:', hex.row, hex.col);
                    console.log('–¶–µ–Ω—Ç—Ä —è—á–µ–π–∫–∏:', hex.hexX, hex.hexY);
                    console.log('–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ:', hex.distance);
                    
                    debugInfo.innerHTML = `–ö–ª–∏–∫: x=${Math.floor(x)}, y=${Math.floor(y)}<br>
                                          –Ø—á–µ–π–∫–∞: —Å—Ç—Ä–æ–∫–∞=${hex.row}, —Å—Ç–æ–ª–±–µ—Ü=${hex.col}<br>
                                          –¶–µ–Ω—Ç—Ä: [${Math.floor(hex.hexX)},${Math.floor(hex.hexY)}]<br>
                                          –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ: ${Math.floor(hex.distance)}`;
                    debugInfo.style.display = 'block';
                    
                    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π –∫–ª–∏–∫
                    this.lastClickedHexMyBoard = hex;
                    this.updateLastClickInfo();
                    
                    // –ï—Å–ª–∏ –≤—ã–±—Ä–∞–Ω –∫–æ—Ä–∞–±–ª—å - –ø—ã—Ç–∞–µ–º—Å—è —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å
                    if (this.selectedShip) {
                        if (this.placeShip(hex.row, hex.col, this.selectedShip, this.shipOrientation)) {
                            const shipElement = document.querySelector(`.ship[data-ship-index="${this.selectedShip.typeIndex}"][data-ship-instance="${this.selectedShip.instance}"]`);
                            if (shipElement) {
                                shipElement.classList.add('placed');
                                shipElement.classList.remove('selected');
                            }
                            
                            this.selectedShip = null;
                            this.lastHoveredHex = null;
                            this.drawBoards();
                            this.updateScores();
                            
                            if (this.allShipsPlaced()) {
                                document.getElementById('startGame').style.display = 'block';
                                
                                if (this.isOnline && this.isHost) {
                                    this.sendData({
                                        type: 'ready',
                                        ships: this.myShips
                                    });
                                }
                            }
                        } else {
                            debugInfo.innerHTML += '<br><span style="color:red">–ù–µ–ª—å–∑—è —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å –∑–¥–µ—Å—å!</span>';
                        }
                    } else {
                        // –ï—Å–ª–∏ –∫–æ—Ä–∞–±–ª—å –Ω–µ –≤—ã–±—Ä–∞–Ω - –ø—ã—Ç–∞–µ–º—Å—è —É–¥–∞–ª–∏—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π
                        this.removeShipAt(hex.row, hex.col);
                    }
                } else {
                    debugInfo.innerHTML = `–ö–ª–∏–∫: x=${Math.floor(x)}, y=${Math.floor(y)} -> –≤–Ω–µ –ø–æ–ª—è`;
                    debugInfo.style.display = 'block';
                }
                
                this.drawBoards();
            }
            
            handleOpponentBoardClick(x, y) {
                if (this.gamePhase !== 'battle' || this.currentPlayer !== 'me') return;
                
                console.log(`–ö–ª–∏–∫ –ø–æ –ø–æ–ª—é –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞: x=${x}, y=${y}`);
                
                const hex = this.getHexAtPosition(x, y, this.opponentBoardCanvas);
                
                const debugInfo = document.getElementById('debugInfo');
                if (hex) {
                    console.log(`–ù–∞–π–¥–µ–Ω–∞ —è—á–µ–π–∫–∞: row=${hex.row}, col=${hex.col}`);
                    debugInfo.innerHTML = `–í—ã—Å—Ç—Ä–µ–ª: x=${Math.floor(x)}, y=${Math.floor(y)}<br>
                                          –Ø—á–µ–π–∫–∞: —Å—Ç—Ä–æ–∫–∞=${hex.row}, —Å—Ç–æ–ª–±–µ—Ü=${hex.col}<br>
                                          –¶–µ–Ω—Ç—Ä: [${Math.floor(hex.hexX)},${Math.floor(hex.hexY)}]<br>
                                          –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ: ${Math.floor(hex.distance)}`;
                    debugInfo.style.display = 'block';
                    
                    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π –∫–ª–∏–∫
                    this.lastClickedHexOpponentBoard = hex;
                    this.updateLastClickInfo();
                } else {
                    debugInfo.innerHTML = `–í—ã—Å—Ç—Ä–µ–ª: x=${Math.floor(x)}, y=${Math.floor(y)} -> –≤–Ω–µ –ø–æ–ª—è`;
                    debugInfo.style.display = 'block';
                }
                
                if (hex && !this.isAlreadyShot(hex.row, hex.col, this.myShots)) {
                    this.makeShot(hex.row, hex.col);
                }
                
                this.drawBoards();
            }
            
            // –ü–†–ê–í–ò–õ–¨–ù–´–ï –ù–ê–ü–†–ê–í–õ–ï–ù–ò–Ø –î–õ–Ø –ì–ï–ö–°–ê–ì–û–ù–ê–õ–¨–ù–û–ô –°–ï–¢–ö–ò
            getShipPositions(row, col, size, orientation) {
                const positions = [{ row, col }];
                let currentRow = row;
                let currentCol = col;
                
                // 6 –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π –≤ –≥–µ–∫—Å–∞–≥–æ–Ω–∞–ª—å–Ω–æ–π —Å–µ—Ç–∫–µ —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º –∑–∏–≥–∑–∞–≥–æ–æ–±—Ä–∞–∑–Ω—ã–º –ø–∞—Ç—Ç–µ—Ä–Ω–æ–º
                const directions = [
                    // –í–µ—Ä—Ç–∏–∫–∞–ª—å –≤–Ω–∏–∑ (‚Üì)
                    () => ({ dr: 1, dc: 0 }),
                    
                    // –î–∏–∞–≥–æ–Ω–∞–ª—å –≤–Ω–∏–∑-–≤–ø—Ä–∞–≤–æ (‚Üò) - –∑–∏–≥–∑–∞–≥–æ–æ–±—Ä–∞–∑–Ω—ã–π –ø–∞—Ç—Ç–µ—Ä–Ω
                    (step) => step % 2 === 0 ? { dr: 0, dc: 1 } : { dr: 1, dc: 0 },
                    
                    // –î–∏–∞–≥–æ–Ω–∞–ª—å –≤–Ω–∏–∑-–≤–ª–µ–≤–æ (‚Üô) - –∑–∏–≥–∑–∞–≥–æ–æ–±—Ä–∞–∑–Ω—ã–π –ø–∞—Ç—Ç–µ—Ä–Ω
                    (step) => step % 2 === 0 ? { dr: 0, dc: -1 } : { dr: 1, dc: 0 },
                    
                    // –í–µ—Ä—Ç–∏–∫–∞–ª—å –≤–≤–µ—Ä—Ö (‚Üë)
                    () => ({ dr: -1, dc: 0 }),
                    
                    // –î–∏–∞–≥–æ–Ω–∞–ª—å –≤–≤–µ—Ä—Ö-–≤–ª–µ–≤–æ (‚Üñ) - –∑–∏–≥–∑–∞–≥–æ–æ–±—Ä–∞–∑–Ω—ã–π –ø–∞—Ç—Ç–µ—Ä–Ω
                    (step) => step % 2 === 0 ? { dr: 0, dc: -1 } : { dr: -1, dc: 0 },
                    
                    // –î–∏–∞–≥–æ–Ω–∞–ª—å –≤–≤–µ—Ä—Ö-–≤–ø—Ä–∞–≤–æ (‚Üó) - –∑–∏–≥–∑–∞–≥–æ–æ–±—Ä–∞–∑–Ω—ã–π –ø–∞—Ç—Ç–µ—Ä–Ω
                    (step) => step % 2 === 0 ? { dr: 0, dc: 1 } : { dr: -1, dc: 0 }
                ];
                
                const directionFunc = directions[orientation];
                
                for (let i = 1; i < size; i++) {
                    const dir = directionFunc(i - 1);
                    currentRow += dir.dr;
                    currentCol += dir.dc;
                    
                    if (!this.isValidPosition(currentRow, currentCol)) {
                        return null;
                    }
                    
                    positions.push({ row: currentRow, col: currentCol });
                }
                
                return positions;
            }
            
            isValidPosition(row, col) {
                return row >= 0 && row < this.boardSize && col >= 0 && col < this.boardSize;
            }
            
            // –ü–†–ê–í–ò–õ–¨–ù–ê–Ø –ü–†–û–í–ï–†–ö–ê –°–û–°–ï–î–ù–ò–• –ö–õ–ï–¢–û–ö –î–õ–Ø –ì–ï–ö–°–ê–ì–û–ù–ê–õ–¨–ù–û–ô –°–ï–¢–ö–ò
            getNeighborCells(row, col) {
                const neighbors = [];
                
                // 6 –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π –¥–ª—è –≥–µ–∫—Å–∞–≥–æ–Ω–∞–ª—å–Ω–æ–π —Å–µ—Ç–∫–∏
                const directions = [
                    { dr: 1, dc: 0 },   // –í–Ω–∏–∑
                    { dr: 1, dc: 1 },   // –í–Ω–∏–∑-–≤–ø—Ä–∞–≤–æ
                    { dr: 1, dc: -1 },  // –í–Ω–∏–∑-–≤–ª–µ–≤–æ
                    { dr: -1, dc: 0 },  // –í–≤–µ—Ä—Ö
                    { dr: -1, dc: -1 }, // –í–≤–µ—Ä—Ö-–≤–ª–µ–≤–æ
                    { dr: -1, dc: 1 }   // –í–≤–µ—Ä—Ö-–≤–ø—Ä–∞–≤–æ
                ];
                
                for (const dir of directions) {
                    const newRow = row + dir.dr;
                    const newCol = col + dir.dc;
                    
                    if (this.isValidPosition(newRow, newCol)) {
                        neighbors.push({ row: newRow, col: newCol });
                    }
                }
                
                return neighbors;
            }
            
            // –ü–†–û–í–ï–†–ö–ê –í–û–ó–ú–û–ñ–ù–û–°–¢–ò –†–ê–ó–ú–ï–©–ï–ù–ò–Ø –ö–û–†–ê–ë–õ–Ø (–ë–ï–ó –ö–ê–°–ê–ù–ò–Ø –î–†–£–ì–ò–• –ö–û–†–ê–ë–õ–ï–ô)
            canPlaceShip(positions) {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –≤—Å–µ –∫–ª–µ—Ç–∫–∏ –∫–æ—Ä–∞–±–ª—è —Å–≤–æ–±–æ–¥–Ω—ã
                for (const pos of positions) {
                    if (!this.isValidPosition(pos.row, pos.col) || this.myBoard[pos.row][pos.col] !== '') {
                        return false;
                    }
                }
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å–µ–¥–µ–π –¥–ª—è –í–°–ï–• –∫–ª–µ—Ç–æ–∫ –∫–æ—Ä–∞–±–ª—è
                const allNeighbors = new Set();
                
                // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ—Ö —Å–æ—Å–µ–¥–µ–π –≤—Å–µ—Ö –∫–ª–µ—Ç–æ–∫ –∫–æ—Ä–∞–±–ª—è
                for (const pos of positions) {
                    const neighbors = this.getNeighborCells(pos.row, pos.col);
                    for (const neighbor of neighbors) {
                        const key = `${neighbor.row},${neighbor.col}`;
                        allNeighbors.add(key);
                    }
                }
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —Å—Ä–µ–¥–∏ —Å–æ—Å–µ–¥–µ–π –Ω–µ—Ç –¥—Ä—É–≥–∏—Ö –∫–æ—Ä–∞–±–ª–µ–π
                for (const key of allNeighbors) {
                    const [r, c] = key.split(',').map(Number);
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —ç—Ç–∞ –∫–ª–µ—Ç–∫–∞ –Ω–µ —è–≤–ª—è–µ—Ç—Å—è —á–∞—Å—Ç—å—é —Ç–µ–∫—É—â–µ–≥–æ –∫–æ—Ä–∞–±–ª—è
                    const isPartOfCurrentShip = positions.some(pos => 
                        pos.row === r && pos.col === c
                    );
                    
                    if (!isPartOfCurrentShip && this.myBoard[r][c] === 'ship') {
                        return false;
                    }
                }
                
                return true;
            }
            
            placeShip(row, col, ship, orientation) {
                const positions = this.getShipPositions(row, col, ship.size, orientation);
                
                if (!positions) return false;
                
                if (!this.canPlaceShip(positions)) {
                    return false;
                }
                
                const shipData = {
                    positions: positions,
                    hits: Array(ship.size).fill(false),
                    size: ship.size,
                    typeIndex: ship.typeIndex,
                    instance: ship.instance
                };
                
                for (const pos of positions) {
                    this.myBoard[pos.row][pos.col] = 'ship';
                }
                
                this.myShips.push(shipData);
                return true;
            }
            
            removeShipAt(row, col) {
                if (this.myBoard[row][col] !== 'ship') return;
                
                const shipIndex = this.myShips.findIndex(ship => 
                    ship.positions.some(pos => pos.row === row && pos.col === col)
                );
                
                if (shipIndex !== -1) {
                    const ship = this.myShips[shipIndex];
                    
                    for (const pos of ship.positions) {
                        this.myBoard[pos.row][pos.col] = '';
                    }
                    
                    this.myShips.splice(shipIndex, 1);
                    this.updateShipPalette();
                    
                    this.drawBoards();
                    this.updateScores();
                    
                    if (!this.allShipsPlaced()) {
                        document.getElementById('startGame').style.display = 'none';
                    }
                }
            }
            
            updateShipPalette() {
                const palette = document.getElementById('shipPalette');
                const shipElements = palette.querySelectorAll('.ship');
                
                shipElements.forEach(shipElement => {
                    shipElement.classList.remove('placed');
                });
                
                this.myShips.forEach(ship => {
                    const shipElement = document.querySelector(
                        `.ship[data-ship-index="${ship.typeIndex}"][data-ship-instance="${ship.instance}"]`
                    );
                    if (shipElement) {
                        shipElement.classList.add('placed');
                    }
                });
            }
            
            randomizeShips() {
                this.initializeGame();
                
                this.ships.forEach((shipType, typeIndex) => {
                    for (let i = 0; i < shipType.count; i++) {
                        let placed = false;
                        let attempts = 0;
                        
                        while (!placed && attempts < 500) {
                            const row = Math.floor(Math.random() * this.boardSize);
                            const col = Math.floor(Math.random() * this.boardSize);
                            const orientation = Math.floor(Math.random() * 6);
                            
                            const ship = {
                                typeIndex: typeIndex,
                                instance: i,
                                size: shipType.size
                            };
                            
                            const positions = this.getShipPositions(row, col, ship.size, orientation);
                            
                            if (positions && this.canPlaceShip(positions)) {
                                const shipData = {
                                    positions: positions,
                                    hits: Array(shipType.size).fill(false),
                                    size: shipType.size,
                                    typeIndex: typeIndex,
                                    instance: i
                                };
                                
                                for (const pos of positions) {
                                    this.myBoard[pos.row][pos.col] = 'ship';
                                }
                                
                                this.myShips.push(shipData);
                                placed = true;
                            }
                            attempts++;
                        }
                    }
                });
                
                this.createShipPalette();
                this.drawBoards();
                this.updateScores();
                
                if (this.allShipsPlaced()) {
                    document.getElementById('startGame').style.display = 'block';
                    
                    if (this.isOnline && this.isHost) {
                        this.sendData({
                            type: 'ready',
                            ships: this.myShips
                        });
                    }
                }
            }
            
            allShipsPlaced() {
                let totalShips = 0;
                this.ships.forEach(shipType => {
                    totalShips += shipType.count;
                });
                
                return this.myShips.length === totalShips;
            }
            
            startBattle() {
                if (!this.allShipsPlaced()) return;
                
                this.gamePhase = 'battle';
                this.currentPlayer = 'me';
                this.updateGamePhase();
                this.drawBoards();
                
                if (this.isOnline) {
                    this.sendData({
                        type: 'start_battle'
                    });
                }
            }
            
            makeShot(row, col) {
                if (this.gamePhase !== 'battle') return;
                
                this.myShots.push({ row, col });
                
                let hit = false;
                let sunkShip = null;
                
                for (const ship of this.opponentShips) {
                    for (let i = 0; i < ship.positions.length; i++) {
                        const pos = ship.positions[i];
                        if (pos.row === row && pos.col === col) {
                            hit = true;
                            ship.hits[i] = true;
                            
                            if (ship.hits.every(h => h)) {
                                sunkShip = ship;
                            }
                            break;
                        }
                    }
                    if (hit) break;
                }
                
                this.opponentBoard[row][col] = hit ? 'hit' : 'miss';
                
                this.drawBoards();
                this.updateScores();
                
                if (this.checkGameOver()) {
                    this.gamePhase = 'gameover';
                    this.updateGamePhase();
                    setTimeout(() => alert('–í—ã –ø–æ–±–µ–¥–∏–ª–∏!'), 100);
                    return;
                }
                
                if (this.isOnline) {
                    this.sendData({
                        type: 'shot',
                        row: row,
                        col: col,
                        hit: hit,
                        sunkShip: sunkShip
                    });
                    
                    if (!hit) {
                        this.currentPlayer = 'opponent';
                        this.updateGamePhase();
                    }
                } else {
                    if (!hit) {
                        this.currentPlayer = 'opponent';
                        this.updateGamePhase();
                        setTimeout(() => this.makeBotMove(), 800);
                    }
                }
            }
            
            makeBotMove() {
                if (this.gamePhase !== 'battle' || this.currentPlayer !== 'opponent') return;
                
                let row, col;
                let attempts = 0;
                
                do {
                    row = Math.floor(Math.random() * this.boardSize);
                    col = Math.floor(Math.random() * this.boardSize);
                    attempts++;
                } while (this.isAlreadyShot(row, col, this.opponentShots) && attempts < 100);
                
                if (attempts < 100) {
                    this.receiveShot(row, col);
                }
            }
            
            receiveShot(row, col) {
                if (this.gamePhase !== 'battle') return;
                
                this.opponentShots.push({ row, col });
                
                let hit = false;
                let sunkShip = null;
                
                for (const ship of this.myShips) {
                    for (let i = 0; i < ship.positions.length; i++) {
                        const pos = ship.positions[i];
                        if (pos.row === row && pos.col === col) {
                            hit = true;
                            ship.hits[i] = true;
                            
                            if (ship.hits.every(h => h)) {
                                sunkShip = ship;
                            }
                            break;
                        }
                    }
                    if (hit) break;
                }
                
                this.myBoard[row][col] = hit ? 'hit' : 'miss';
                
                this.drawBoards();
                this.updateScores();
                
                if (this.checkGameOver()) {
                    this.gamePhase = 'gameover';
                    this.updateGamePhase();
                    setTimeout(() => alert('–ü—Ä–æ—Ç–∏–≤–Ω–∏–∫ –ø–æ–±–µ–¥–∏–ª!'), 100);
                    return;
                }
                
                if (this.isOnline) {
                    this.sendData({
                        type: 'shot_result',
                        row: row,
                        col: col,
                        hit: hit,
                        sunkShip: sunkShip
                    });
                    
                    if (!hit) {
                        this.currentPlayer = 'me';
                        this.updateGamePhase();
                    }
                } else {
                    if (!hit) {
                        this.currentPlayer = 'me';
                        this.updateGamePhase();
                    }
                }
            }
            
            isAlreadyShot(row, col, shots) {
                return shots.some(shot => shot.row === row && shot.col === col);
            }
            
            checkGameOver() {
                const myShipsSunk = this.myShips.every(ship => ship.hits.every(h => h));
                const opponentShipsSunk = this.opponentShips.every(ship => ship.hits.every(h => h));
                
                return myShipsSunk || opponentShipsSunk;
            }
            
            updateGamePhase() {
                const phaseElement = document.getElementById('gamePhase');
                
                switch (this.gamePhase) {
                    case 'setup':
                        phaseElement.textContent = '–§–∞–∑–∞ —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∏ –∫–æ—Ä–∞–±–ª–µ–π';
                        break;
                    case 'battle':
                        phaseElement.textContent = `–§–∞–∑–∞ –±–æ—è - –•–æ–¥: ${this.currentPlayer === 'me' ? '–í–∞—à' : '–ü—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞'}`;
                        break;
                    case 'gameover':
                        phaseElement.textContent = '–ò–≥—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞';
                        break;
                }
                
                document.getElementById('playerMe').classList.toggle('active', this.currentPlayer === 'me');
                document.getElementById('playerOpponent').classList.toggle('active', this.currentPlayer === 'opponent');
            }
            
            updateScores() {
                const myAliveShips = this.myShips.filter(ship => !ship.hits.every(h => h)).length;
                const opponentAliveShips = this.opponentShips.filter(ship => !ship.hits.every(h => h)).length;
                
                document.getElementById('scoreMe').textContent = `${myAliveShips} –∫–æ—Ä–∞–±–ª–µ–π`;
                document.getElementById('scoreOpponent').textContent = `${opponentAliveShips} –∫–æ—Ä–∞–±–ª–µ–π`;
            }
            
            drawBoards() {
                this.drawBoard(this.myCtx, this.myBoardCanvas, this.myBoard, this.myShips, true);
                this.drawBoard(this.opponentCtx, this.opponentBoardCanvas, this.opponentBoard, this.opponentShips, false);
            }
            
            drawBoard(ctx, canvas, board, ships, showShips) {
                // –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã canvas (—É–∂–µ —Å —É—á–µ—Ç–æ–º DPR)
                const canvasWidth = canvas.width / (window.devicePixelRatio || 1);
                const canvasHeight = canvas.height / (window.devicePixelRatio || 1);
                
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                
                // –û–¢–õ–ê–î–ö–ê: –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ä–∞–∑–º–µ—Ä–∞—Ö
                if (this.showTouchZones) {
                    ctx.fillStyle = 'red';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(`Canvas: ${Math.floor(canvasWidth)}x${Math.floor(canvasHeight)}`, 10, 15);
                }
                
                // –†–∏—Å—É–µ–º –≤—Å–µ –≥–µ–∫—Å—ã –∏—Å–ø–æ–ª—å–∑—É—è –û–î–ò–ù –º–µ—Ç–æ–¥ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
                for (let row = 0; row < this.boardSize; row++) {
                    for (let col = 0; col < this.boardSize; col++) {
                        const center = this.getHexCenter(row, col, canvas);
                        const isLastClicked = 
                            (showShips && this.lastClickedHexMyBoard && 
                             this.lastClickedHexMyBoard.row === row && this.lastClickedHexMyBoard.col === col) ||
                            (!showShips && this.lastClickedHexOpponentBoard && 
                             this.lastClickedHexOpponentBoard.row === row && this.lastClickedHexOpponentBoard.col === col);
                        
                        this.drawHex(ctx, center.x, center.y, center.hexSize, board[row][col], showShips, row, col, isLastClicked);
                        
                        // –û–¢–õ–ê–î–ö–ê: —Ü–µ–Ω—Ç—Ä—ã –∏ –∑–æ–Ω—ã –∫–ª–∏–∫–∞
                        if (this.showTouchZones) {
                            // –ö—Ä–∞—Å–Ω–∞—è —Ç–æ—á–∫–∞ –≤ —Ü–µ–Ω—Ç—Ä–µ
                            ctx.fillStyle = 'red';
                            ctx.beginPath();
                            ctx.arc(center.x, center.y, 3, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // –ó–µ–ª–µ–Ω–∞—è –∑–æ–Ω–∞ –∫–ª–∏–∫–∞
                            ctx.strokeStyle = 'lime';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.arc(center.x, center.y, center.hexSize * 0.9, 0, Math.PI * 2);
                            ctx.stroke();
                            
                            // –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
                            ctx.fillStyle = 'yellow';
                            ctx.font = '10px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText(`${row},${col}`, center.x, center.y - 15);
                        }
                    }
                }
                
                // –ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –∫–æ—Ä–∞–±–ª—è
                if (this.gamePhase === 'setup' && this.selectedShip && showShips && this.lastHoveredHex) {
                    const positions = this.getShipPositions(this.lastHoveredHex.row, this.lastHoveredHex.col, this.selectedShip.size, this.shipOrientation);
                    
                    if (positions && positions.length === this.selectedShip.size) { // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –ø–æ–ª—É—á–∏–ª–∏ –≤—Å–µ –∫–ª–µ—Ç–∫–∏
                        let valid = this.canPlaceShip(positions);
                        
                        ctx.globalAlpha = 0.6;
                        for (const pos of positions) {
                            const center = this.getHexCenter(pos.row, pos.col, canvas);
                            this.drawHex(ctx, center.x, center.y, center.hexSize, valid ? 'ship-preview' : 'invalid-preview', showShips, pos.row, pos.col, false);
                        }
                        ctx.globalAlpha = 1.0;
                        
                        // –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
                        if (this.showTouchZones) {
                            ctx.fillStyle = valid ? 'lime' : 'red';
                            ctx.font = '12px Arial';
                            ctx.textAlign = 'left';
                            ctx.fillText(`–ö–æ—Ä–∞–±–ª—å: ${positions.length} –∏–∑ ${this.selectedShip.size} –∫–ª–µ—Ç–æ–∫`, 10, 30);
                        }
                    }
                }
            }
            
            drawHex(ctx, x, y, hexSize, state, showShips, row, col, isLastClicked) {
                // –†–∏—Å—É–µ–º —à–µ—Å—Ç–∏—É–≥–æ–ª—å–Ω–∏–∫
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = Math.PI / 3 * i;
                    const hexX = x + hexSize * Math.cos(angle);
                    const hexY = y + hexSize * Math.sin(angle);
                    if (i === 0) ctx.moveTo(hexX, hexY);
                    else ctx.lineTo(hexX, hexY);
                }
                ctx.closePath();
                
                // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–π –Ω–∞–∂–∞—Ç–æ–π —è—á–µ–π–∫–∏
                if (isLastClicked) {
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                    ctx.fill();
                }
                
                switch (state) {
                    case 'ship':
                        if (showShips) {
                            ctx.fillStyle = '#4CAF50';
                        } else {
                            ctx.fillStyle = 'rgba(0, 0, 50, 0.7)';
                        }
                        break;
                    case 'hit':
                        ctx.fillStyle = '#FF5252';
                        break;
                    case 'miss':
                        ctx.fillStyle = '#2196F3';
                        break;
                    case 'ship-preview':
                        ctx.fillStyle = 'rgba(76, 175, 80, 0.4)';
                        break;
                    case 'invalid-preview':
                        ctx.fillStyle = 'rgba(255, 82, 82, 0.4)';
                        break;
                    default:
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
                }
                
                if (!isLastClicked) {
                    ctx.fill();
                }
                
                ctx.strokeStyle = isLastClicked ? '#FFD700' : 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = isLastClicked ? 3 : 1;
                ctx.stroke();
                
                // –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω–¥–µ–∫—Å—ã –≤ –∫–∞–∂–¥—É—é –∫–ª–µ—Ç–∫—É
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${row},${col}`, x, y);
                
                if (state === 'hit') {
                    ctx.strokeStyle = '#FFF';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x - hexSize * 0.3, y - hexSize * 0.3);
                    ctx.lineTo(x + hexSize * 0.3, y + hexSize * 0.3);
                    ctx.moveTo(x + hexSize * 0.3, y - hexSize * 0.3);
                    ctx.lineTo(x - hexSize * 0.3, y + hexSize * 0.3);
                    ctx.stroke();
                }
                
                if (state === 'miss') {
                    ctx.fillStyle = '#2196F3';
                    ctx.beginPath();
                    ctx.arc(x, y, hexSize * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // –û–ù–õ–ê–ô–ù-–§–£–ù–ö–¶–ò–û–ù–ê–õ–¨–ù–û–°–¢–¨
            createOnlineGame() {
                this.isOnline = true;
                this.isHost = true;
                
                this.peer = new Peer({
                    host: '0.peerjs.com',
                    port: 443,
                    path: '/',
                    pingInterval: 5000
                });
                
                this.peer.on('open', (id) => {
                    this.roomId = id;
                    this.updateConnectionStatus(`–ö–æ–º–Ω–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∞! ID: ${id}`, 'success');
                    document.getElementById('roomInfo').innerHTML = `ID –∫–æ–º–Ω–∞—Ç—ã: <strong>${id}</strong><br>–û–∂–∏–¥–∞–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è...`;
                    document.getElementById('roomInfo').style.display = 'block';
                });
                
                this.peer.on('connection', (conn) => {
                    this.connection = conn;
                    this.setupConnection();
                    this.updateConnectionStatus('–ò–≥—Ä–æ–∫ –ø–æ–¥–∫–ª—é—á–µ–Ω!', 'success');
                });
                
                this.peer.on('error', (err) => {
                    console.error('Peer error:', err);
                    this.updateConnectionStatus('–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: ' + err.type, 'error');
                });
            }
            
            joinOnlineGame() {
                const roomId = document.getElementById('roomIdInput').value.trim();
                if (!roomId) {
                    alert('–í–≤–µ–¥–∏—Ç–µ ID –∫–æ–º–Ω–∞—Ç—ã');
                    return;
                }
                
                this.isOnline = true;
                this.isHost = false;
                
                this.peer = new Peer({
                    host: '0.peerjs.com',
                    port: 443,
                    path: '/',
                    pingInterval: 5000
                });
                
                this.peer.on('open', (id) => {
                    this.roomId = roomId;
                    this.connection = this.peer.connect(roomId);
                    this.setupConnection();
                    this.updateConnectionStatus('–ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ –∫–æ–º–Ω–∞—Ç–µ...', 'info');
                });
                
                this.peer.on('error', (err) => {
                    console.error('Peer error:', err);
                    this.updateConnectionStatus('–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: ' + err.type, 'error');
                });
            }
            
            setupConnection() {
                this.connection.on('open', () => {
                    this.updateConnectionStatus('–ü–æ–¥–∫–ª—é—á–µ–Ω–æ!', 'success');
                    if (!this.isHost) {
                        this.sendData({ type: 'request_state' });
                    }
                });
                
                this.connection.on('data', (data) => {
                    this.handleOnlineData(data);
                });
                
                this.connection.on('close', () => {
                    this.updateConnectionStatus('–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Ä–∞–∑–æ—Ä–≤–∞–Ω–æ', 'error');
                    this.leaveOnlineGame();
                });
                
                this.connection.on('error', (err) => {
                    console.error('Connection error:', err);
                    this.updateConnectionStatus('–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è', 'error');
                });
            }
            
            handleOnlineData(data) {
                console.log("–ü–æ–ª—É—á–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ:", data);
                
                switch (data.type) {
                    case 'ready':
                        if (this.isHost) {
                            this.opponentShips = data.ships;
                            this.sendData({
                                type: 'game_state',
                                ships: this.myShips,
                                gamePhase: this.gamePhase
                            });
                        }
                        break;
                        
                    case 'game_state':
                        this.opponentShips = data.ships;
                        this.gamePhase = data.gamePhase;
                        this.updateGamePhase();
                        this.drawBoards();
                        break;
                        
                    case 'start_battle':
                        this.startBattle();
                        break;
                        
                    case 'shot':
                        this.receiveShot(data.row, data.col);
                        break;
                        
                    case 'shot_result':
                        this.opponentBoard[data.row][data.col] = data.hit ? 'hit' : 'miss';
                        
                        if (data.sunkShip) {
                            this.opponentShips.forEach(ship => {
                                if (ship.typeIndex === data.sunkShip.typeIndex && 
                                    ship.instance === data.sunkShip.instance) {
                                    ship.hits = data.sunkShip.hits;
                                }
                            });
                        }
                        
                        this.drawBoards();
                        this.updateScores();
                        
                        if (!data.hit) {
                            this.currentPlayer = 'me';
                            this.updateGamePhase();
                        }
                        break;
                        
                    case 'request_state':
                        if (this.isHost) {
                            this.sendData({
                                type: 'game_state',
                                ships: this.myShips,
                                gamePhase: this.gamePhase
                            });
                        }
                        break;
                }
            }
            
            sendData(data) {
                if (this.connection && this.connection.open) {
                    this.connection.send(data);
                    return true;
                } else {
                    console.warn("–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –Ω–µ –æ—Ç–∫—Ä—ã—Ç–æ, –¥–∞–Ω–Ω—ã–µ –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã");
                    this.updateConnectionStatus("–û—à–∏–±–∫–∞: –Ω–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è", "error");
                    return false;
                }
            }
            
            updateConnectionStatus(message, type) {
                const statusElement = document.getElementById('connectionStatus');
                statusElement.textContent = message;
                statusElement.style.display = 'block';
                statusElement.style.background = type === 'success' ? 'rgba(212, 237, 218, 0.2)' : 
                                               type === 'error' ? 'rgba(248, 215, 218, 0.2)' : 'rgba(209, 236, 241, 0.2)';
                statusElement.style.color = type === 'success' ? '#d4edda' : 
                                           type === 'error' ? '#f8d7da' : '#d1ecf1';
            }
            
            leaveOnlineGame() {
                if (this.connection) {
                    this.connection.close();
                }
                if (this.peer) {
                    this.peer.destroy();
                }
                this.isOnline = false;
                this.initializeGame();
            }
        }

        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –∫–Ω–æ–ø–æ–∫ HTML
        function createOnlineGame() {
            const game = document.querySelector('script')._gameInstance;
            if (game) {
                game.createOnlineGame();
            }
        }

        function joinOnlineGame() {
            const game = document.querySelector('script')._gameInstance;
            if (game) {
                game.joinOnlineGame();
            }
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã
        document.addEventListener('DOMContentLoaded', () => {
            const game = new HexagonalBattleship();
            document.querySelector('script')._gameInstance = game;
        });
    </script>
</body>
</html>